<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Emwin】xbf字体制作及使用方法</title>
    <url>/posts/00000009/</url>
    <content><![CDATA[<h2 id="xbf字体的制作"><a href="#xbf字体的制作" class="headerlink" title="xbf字体的制作"></a>xbf字体的制作</h2><p>FontCvtST.exe软件是EWINM提供制作XBF字体和Slf字体的软件。</p>
<ol>
<li><p>打开FontCvtST.exe，选择字体生成类型为Standard, 编码为16 Bit Unicode</p>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageXBF%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%901.jpg" alt=""></p>
</li>
<li><p>选择生成字体，字形，大小</p>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageXBF%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%902.png" alt=""> </p>
</li>
<li><p>设置生成字体属性后的界面</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageXBF%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%903.png" alt=""></p>
<ol start="4">
<li><p>保存并生成XBF字体</p>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageXBF%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%904.png" alt=""></p>
</li>
</ol>
<h2 id="XBF字体使用"><a href="#XBF字体使用" class="headerlink" title="XBF字体使用"></a>XBF字体使用</h2><ul>
<li><p>使用XBF字体的注意事项</p>
<ol>
<li>使用XBF字体之前，需要调用GUI_UC_SetEncodeUTF8();</li>
<li>使用XBF字体之前，需要从外部存储中将XBF字体文件加载到内存中，并创建该字体</li>
<li>使用XBF字体时，需要打开XBF文件，如果之后不使用，则可以关闭这个文件；如果后面还需使用，则不能关闭该文件。</li>
<li>使用XBF字体时，需要把C文件的编码格式改为UTF-8,不然是无法使用。</li>
</ol>
</li>
<li><p>相关函数</p>
</li>
</ul>
<ul>
<li>XBF字体使用示例</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">void MainTask(void) {
  HANDLE hFile;

  GUI_Init();
  /*在使用XBF字体之前一定要调用该函数*/
  GUI_UC_SetEncodeUTF8();

  WM_SetCallback(WM_HBKWIN, _cbDesktop);

  char* acPath = "C:\\Users\\wl\\Desktop\\SeggerEval_WIN32_MSVC_MinGW_GUI_V610\\demo\\xbf\\song16.xbf";

  /*打开xbf字体文件*/

  hFile = CreateFile(acPath, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  if (hFile != INVALID_HANDLE_VALUE)
  {
    /*vs 2019在编译UTF-8有时会出问题，
    一般只需在显示文字后面加.即可解决*/

    char* acShowString = "安富莱电子_ \n";

      /*创建XBF字体*/
    GUI_XBF_CreateFont(&Font,&XBF_Data,GUI_XBF_TYPE_PROP,_cbGetData, &hFile);
    GUI_DispStringHCenterAt("Press any key to continue...", 160, 120);
    GUI_SetFont(&Font);
    GUI_DispStringHCenterAt(acShowString, 160, 80);
      //CloseHandle(hFile);
  }
  else
  {
      GUI_DispStringAt("open fail", 100, 100);
  }

  while(1)
  {
    GUI_ExecDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), &_cbDialog, 0, 0, 0);
    GUI_Delay(1000);
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Emwin</category>
      </categories>
      <tags>
        <tag>Emwin</tag>
      </tags>
  </entry>
  <entry>
    <title>【Emwin】日历控件的使用</title>
    <url>/posts/0000000a/</url>
    <content><![CDATA[<h2 id="日历控件"><a href="#日历控件" class="headerlink" title="日历控件"></a>日历控件</h2><p>  日历对话框可用于选择或设置日期。</p>
<ul>
<li>日历控件可以支持的通知消息</li>
</ul>
<table>
<thead>
<tr>
<th align="center">消息</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CALENDAR_NOTIFICATION_MONTH_CLICKED</td>
<td align="center">月份/年份文本已被单击</td>
</tr>
<tr>
<td align="center">CALENDAR_NOTIFICATION_MONTH_RELEASED</td>
<td align="center">月份/年份文本已被释放</td>
</tr>
<tr>
<td align="center">WM_NOTIFICATION_CLICKED</td>
<td align="center">小部件被点击</td>
</tr>
<tr>
<td align="center">WM_NOTIFICATION_RELEASED</td>
<td align="center">小部件被释放</td>
</tr>
<tr>
<td align="center">WM_NOTIFICATION_SCROLL_CHANGED</td>
<td align="center">其中一个滚动按钮被按下</td>
</tr>
<tr>
<td align="center">WM_NOTIFICATION_SEL_CHANGED</td>
<td align="center">控件发生改变</td>
</tr>
</tbody></table>
<ul>
<li>日历控件支持的键盘反应</li>
</ul>
<table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">反应</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GUI_KEY_PGUP</td>
<td align="center">选择移回一个月前</td>
</tr>
<tr>
<td align="center">GUI_KEY_PGDOWN</td>
<td align="center">选择移回一个月后</td>
</tr>
<tr>
<td align="center">GUI_KEY_LEFT</td>
<td align="center">选择移动到左边</td>
</tr>
<tr>
<td align="center">GUI_KEY_RIGHT</td>
<td align="center">选择移动到右边</td>
</tr>
<tr>
<td align="center">GUI_KEY_UP</td>
<td align="center">选择向上移动一行</td>
</tr>
<tr>
<td align="center">GUI_KEY_DOWN</td>
<td align="center">选择向下移动一行</td>
</tr>
</tbody></table>
<h2 id="日历控件的相关函数"><a href="#日历控件的相关函数" class="headerlink" title="日历控件的相关函数"></a>日历控件的相关函数</h2><ul>
<li>创建一个日历控件</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">   原型：WM_HWIN CALENDAR_Create(WM_HWIN hParent,
                                 int xPos,
                                 int yPos,
                                 unsigned Year,
                                 unsigned Month,
                                 unsigned Day,
                                 unsigned FirstDayOfWeek,
                                 int Id,
                                 int Flags); 
   参数：hParent   接收NOTIFICATION 消息的父窗口的句柄
         xPos      客户端坐标中对话框的X位置(以像素为单位)
         yPos      客户端坐标中对话框的Y位置(以像素为单位)
         Year      当前的年数 (1582-9999)
         Month     当前的月份 (1-12)
         Day       当前的天数 (1-31)
         FirstDayOfWeek   日历控件从哪一个工作日开始(0-6 0=SA, 1=SO, … , 6=FR)
         Id        创建日历控件所使用的ID
         Flags     窗口小部件的附加标志(例如 WM_CF_SHOW  WM_CF_TRANS)

  返回值：成功对话框的句柄，否则为0

  注意：使用时一定要注意Year、Month、Day这个三个参数一定要在范围之内，要不然就会日历控件创建失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置用于新日历对话框的默认背景颜色</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型： void CALENDAR_SetDefaultBkColor(unsigned Index,GUI_COLOR Color);

  参数：Index 设置日历控件部分位置的背景颜色，具体设置那一部分需要参考下面的
              宏定义。
              CALENDAR_CI_WEEKEND ： 周末使用的背景色
              CALENDAR_CI_WEEKDAY ： 用于工作日的背景色
              CALENDAR_CI_SEL     ： 用于选择的背景颜色
              CALENDAR_CI_HEADER  ： 标题区域使用的背景颜色
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置用于标记日期的文本</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型： void CALENDAR_SetDefaultDays(const char ** apDays);
  参数： apDays : 指向包含字符串的7个字符串指针的数组的指针要使用。

  注意：数组的第一个字符串应该指向星期六的缩写，第二个字符串指向星期天。数组 需要至少有7个字符串。如果传递给函数的字符串太少，则emWin的行为将变得未定义

  例如：
  const char* apDays[] =
{
    "六.",
    "日.",
    "一.",
    "二.",
    "三.",
    "四.",
    "五.",
    "六.",
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置要用于当前月/年的文本</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型：void CALENDAR_SetDefaultMonths(const char ** apMonths);
  参数：apMonth : 指针指向一个包含12个字符串指针的数组要使用的字符串。 

  注意：数组的第一个字符串应该指向“January”的文本，第二个字符串应该指向文本
  例如“二月”等等。数组需要至少有12个字符串。如果太少的话传递给函数的字符串emWin的行为没有定义

  例如：
  const char* apMonths[] =
{
    "1月",
    "2月",
    "3月",
    "4月",
    "5月",
    "6月",
    "7月",
    "8月",
    "9月",
    "10月",
    "11月",
    "12月",
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置对话框使用的大小</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型：void CALENDAR_SetDefaultSize(unsigned Index, unsigned Size);
  参数：Index   要设置日历控件的位置，具体位置参考一下宏
                CALENDAR_SI_HEADER：设置标题区域的ysize
                CALENDAR_SI_CELL_X: 设置日历控件显示日期的单元格Xsize
                CALENDAR_SI_CELL_Y: 设置日历控件显示日期的单元格Ysize

  注意：完整对话框中x的大小可以计算如下:xSizeDialog = 7×CellSizeX
        完整对话框中y的大小可以计算如下:ySizeDialog = 7×CellSize+ HeaderSizeY          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置用于绘制日历控件的字体</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型：void CALENDAR_SetDefaultFont( unsigned Index,
                                      const GUI_FONT *  pFont);
  参数：Index : 用于那部分显示， 具体根据一下宏定以
                CALENDAR_FI_CONTENT ：用于标记和编号的字体
                CALENDAR_FI_HEADER  ：用于标题月/年使用的字体
        pFont : 要使用的字体
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="日历控件的使用"><a href="#日历控件的使用" class="headerlink" title="日历控件的使用"></a>日历控件的使用</h2><pre class="line-numbers language-C"><code class="language-C">  /*获取当前的年月日*/
  _Calendar_Date.Year  = (unsigned int)p->tm_year;
    _Calendar_Date.Month = (unsigned int)p->tm_mon;
    _Calendar_Date.Day   = (unsigned int)p->tm_mday;

    /*日历控件初始化 */
    CALENDAR_SetDefaultDays(apDays);
    CALENDAR_SetDefaultMonths(apMonths);

    CALENDAR_SetDefaultSize(CALENDAR_SI_HEADER, 35);
    CALENDAR_SetDefaultSize(CALENDAR_SI_CELL_X, 40);
    CALENDAR_SetDefaultSize(CALENDAR_SI_CELL_Y, 28);

    CALENDAR_SetDefaultColor(CALENDAR_CI_WEEKDAY, GUI_BLACK);
    CALENDAR_SetDefaultColor(CALENDAR_CI_WEEKEND, GUI_GRAY);
    CALENDAR_SetDefaultColor(CALENDAR_CI_LABEL, GUI_LIGHTBLUE);

    CALENDAR_SetDefaultFont(CALENDAR_FI_CONTENT, &Font);
    CALENDAR_SetDefaultFont(CALENDAR_FI_HEADER, &Font);

    hWinD = CALENDAR_Create(hWin, 450, 22, _Calendar_Date.Year + 1900, _Calendar_Date.Month, _Calendar_Date.Day, 2, GUI_ID_CALENDAR0, WM_CF_SHOW);
    if (hWinD == 0)
    {
        GUI_Log("error");
    }

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Emwin</category>
      </categories>
      <tags>
        <tag>Emwin</tag>
      </tags>
  </entry>
  <entry>
    <title>【keil】 iot_socket组件</title>
    <url>/posts/4/</url>
    <content><![CDATA[<h2 id="iot-socket-组件"><a href="#iot-socket-组件" class="headerlink" title="iot_socket 组件"></a>iot_socket 组件</h2><p> iot_socket 组件是keil对RL_TcpNet的bsd socket API 封装。</p>
<h2 id="iot-socket-API"><a href="#iot-socket-API" class="headerlink" title="iot_socket API"></a>iot_socket API</h2><ul>
<li><p>iotSocketCreate</p>
<pre class="line-numbers language-C"><code class="language-C">原型:int32_t iotSocketCreate (int32_t af, int32_t type, int32_t protocol) 
参数：
  af ：iot socket 地址类型
      IOT_SOCKET_AF_INET  -----   IPV4
      IOT_SOCKET_AF_INET6 -----   IPV6
 type: iot socket连接类型
      IOT_SOCKET_SOCK_STREAM
      IOT_SOCKET_SOCK_DGRAM
 protocol：
      IOT_SOCKET_IPPROTO_TCP ----  tcp协议控制
      IPPROTO_UDP            ----  udp协议控制
返回值：创建的socket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>iotSocketConnect</p>
<pre class="line-numbers language-C"><code class="language-C">原型：int32_t iotSocketConnect (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port)
参数：
  socket：连接的套接字
  ip    : ip地址
  ip_len：IP地址长度
          NET_ADDR_IP4_LEN
          NET_ADDR_IP6_LEN
  port  : 端口
返回值: 状态码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>iotSocketRecv</p>
<pre class="line-numbers language-C"><code class="language-C">原型：int32_t iotSocketRecv (int32_t socket, void *buf, uint32_t len) 
参数：
  socket：连接的套接字
  buf   : 要接收的数据缓冲区
  len   : 接收数据的长度
返回值: >0   接收字节数
     <0   错误码, 参考rc_bsd_to_iot错误码处理函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>iotSocketSend</p>
<pre class="line-numbers language-C"><code class="language-C">原型：int32_t iotSocketSend (int32_t socket, const void *buf, uint32_t len)
参数：
   socket：连接的套接字
   buf   : 发送数据的缓冲区
   len   : 发送数据的长度
返回值：>0  发送字节数
     <0  c错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2 id="使用iot-socket-API-编写客户端接收"><a href="#使用iot-socket-API-编写客户端接收" class="headerlink" title="使用iot socket API 编写客户端接收"></a>使用iot socket API 编写客户端接收</h2><pre class="line-numbers language-C"><code class="language-C"> void iot_thread(void)
{
    int32_t rc;  /*socket 套接字*/
    int32_t res; 
    uint8_t ip[4] = {192, 168, 1, 106};  
    uint16_t port = 2000;

    /*创建socket*/
    rc = iotSocketCreate(IOT_SOCKET_AF_INET, IOT_SOCKET_SOCK_STREAM, IOT_SOCKET_IPPROTO_TCP);

    /*连接指定的ip*/
    iotSocketConnect (rc, ip, NET_ADDR_IP4_LEN, port);

    while(1){

         /*等待接收*/
        res = iotSocketRecv (rc, _gBuf, 8);    
        if(res >= 0)
        {
          printf("iot_ok\r\n");
        }
            osDelay(500);    
   }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用iot-socket-API-编写客户端发送"><a href="#使用iot-socket-API-编写客户端发送" class="headerlink" title="使用iot socket API 编写客户端发送"></a>使用iot socket API 编写客户端发送</h2><pre class="line-numbers language-C"><code class="language-C"> uint8_t _gBuf[8] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};
void iot_thread(void)
{
    int32_t rc;
    int32_t res;
    uint8_t ip[4] = {192, 168, 1, 106};
    uint16_t port = 2000;
    rc = iotSocketCreate(IOT_SOCKET_AF_INET, IOT_SOCKET_SOCK_STREAM, IOT_SOCKET_IPPROTO_TCP);

    iotSocketConnect (rc, ip, NET_ADDR_IP4_LEN, port);

  while(1){

        /*发送数据*/
        res = iotSocketSend(rc, _gBuf, 8);
        if(res > 0 )
        {
           printf("send data %d byte\r\n", res);
        }
            osDelay(500);    
   }


}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>keil 组件</category>
      </categories>
      <tags>
        <tag>RTX5</tag>
      </tags>
  </entry>
  <entry>
    <title>【MQTT】MQTT调试助手mqttfx</title>
    <url>/posts/3/</url>
    <content><![CDATA[<h2 id="1-Mqttfx"><a href="#1-Mqttfx" class="headerlink" title="1. Mqttfx"></a>1. Mqttfx</h2><p>MQTT.fx是一款基于Eclipse Paho，使用Java语言编写的MQTT客户端工具。支持通过Topic订阅和发布消息，用来前期和物理云平台调试非常方便。</p>
<h2 id="2-Mqttfx使用"><a href="#2-Mqttfx使用" class="headerlink" title="2. Mqttfx使用"></a>2. Mqttfx使用</h2><ol>
<li>MQTT基本配置<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_fx.jpg" alt="MQTT基本配置"></li>
<li>MQTT Username及PassWord<br>这个是根据MQTT服务器是否需要UserName和PassWord来配置，有则根据协议规则来配置，没有可以不配。<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_fx_UserName_.png" alt="MQTT Username及PassWord"></li>
<li>MQTT 连接<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_fxConnect.png" alt="MQTT 连接"></li>
<li>MQTT 发布<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_Pulish.png" alt="MQTT 发布"></li>
<li>MQTT 订阅<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_Subscribe.png" alt="MQTT 订阅"></li>
<li>MQTT Debug<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_Debug.png" alt="MQTT Debug"></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>【IAP】STM32 IAP在线升级</title>
    <url>/posts/7/</url>
    <content><![CDATA[<h2 id="STM32在线升级（IAP）"><a href="#STM32在线升级（IAP）" class="headerlink" title="STM32在线升级（IAP）"></a>STM32在线升级（IAP）</h2><h3 id="IAP与ISP"><a href="#IAP与ISP" class="headerlink" title="IAP与ISP"></a>IAP与ISP</h3><ul>
<li><p>ISP </p>
<blockquote>
<p>在系统可编程，指电路板上的空白器件可以编程写入最终用户代码， 而不需要从电路板上取下器件，已经编程的器件也可以用ISP方式擦除或再编程。这种方式需要将将BOOT管脚配置成上电从System Memory启动，System Memory中有一段BOOTLOADER来接收串口(对于STM32F407ZG来说，为USART1)来的数据，把它们烧写到FLASH中。<br>优势：不需要编程器就可以进行单片机的实验和开发，单片机芯片可以直接焊接到电路板上，调试结束即成成品，免去了调试时由于频繁地插入取出芯片对芯片和电路板带来的不便</p>
</blockquote>
</li>
<li><p>IAP</p>
<blockquote>
<p>IAP是In Application Programming的首字母缩写，IAP是用户自己的程序在运行过程中对User Flash的部分区域进行烧写，目的是为了在产品发布后可以方便地通过预留的通信口对产品中的固件程序进行更新升级。<br>优势：从结构上将Flash存储器映射为两个存储体，当运行一个存储体上的用户程序时，可对另一个存储体重新编程，之后将程序从一个存储体转向另一个。</p>
</blockquote>
</li>
</ul>
<h2 id="IAP的执行流程："><a href="#IAP的执行流程：" class="headerlink" title="IAP的执行流程："></a>IAP的执行流程：</h2><ol>
<li>bootload检测是否要升级程序并通过某种方式将固件bin文件传给要升级的设备（例如stm32）。</li>
<li>当升级设备开始接收到数据时，需要开始缓存数据并累计接收数据的大小</li>
<li>当数据接收完毕后即可开始将数据写入指定的内存地址并跳转执行</li>
</ol>
<h3 id="STM32内部FLASH分配"><a href="#STM32内部FLASH分配" class="headerlink" title="STM32内部FLASH分配"></a>STM32内部FLASH分配</h3><ol>
<li><p>正常使用烧写器烧写程序，整个flash中只有一个中断向量和用户代码<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_image20200213095409.jpg" alt="flash分配"></p>
<ol>
<li>IAP程序中分为Bootload,用户程序两部分<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageiapflah.jpg" alt="IAP flash分配"></li>
</ol>
</li>
</ol>
<h3 id="IAP程序实现"><a href="#IAP程序实现" class="headerlink" title="IAP程序实现"></a>IAP程序实现</h3><ol>
<li><p>设置用户代码的的跳转地址</p>
<pre class="line-numbers language-C"><code class="language-C">#define APP_START_ADDR       0x8010000      //应用程序起始地址(存放在FLASH)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>初始化时钟及串口外设</p>
<pre class="line-numbers language-C"><code class="language-C">
 bsp_Init();        /* 硬件初始化 */

 PrintfLogo();    /* 打印例程名称和版本等信息 */
 PrintfHelp();    /* 打印操作提示 */

 FLASH_If_Init();

 /* 如果用户区flash有写保护,在升级之前一定要解除写保护 */
 if (FLASH_If_GetWriteProtectionStatus() == 0)   
 {
     /* 解保护 */
     if(FLASH_If_DisableWriteProtection() == 1)
     {
         /* 解保护成功 */
         printf("\n\r解保护成功\n\r");
     }
     else
     {
         /* 解保护失败 */
         SerialPutString("解保护失败\r\n");
     }
 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>3.检测程序是否升级和升级程序及程序跳转<br>在</p>
<pre class="line-numbers language-C"><code class="language-C">
if(KEY1_StateRead()==KEY_DOWN)                   //如果KEY1被单击
    {

      printf("开始更新 APP\r\n");
      //更新FLASH代码      
          /* 下载新的用户代码到flash里面  */
            SerialDownload();
            printf ( "单击 KEY2，执行 APP\r\n" );
    }            
    else if(KEY2_StateRead()==KEY_DOWN)          //如果KEY2被单击
    {    
            printf ( "执行 APP\r\n" );

            HAL_Delay(1000);

            JumpAddress = *(__IO uint32_t*) (APPLICATION_ADDRESS + 4);
            /* 用户应用地址 */
            Jump_To_Application = (pFunction) JumpAddress;
            /* 初始化MSP */
            __set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);


            Jump_To_Application();
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="用户程序"><a href="#用户程序" class="headerlink" title="用户程序"></a>用户程序</h3><p>1.设置用户程序跳转地址，这个需要设置两个地方，一个是keil里flash地址设置和中断偏移量的设置</p>
<ul>
<li>flash地址设置<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageIAP%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE.png" alt="flash 地址设置"></li>
<li>中断偏移量设置<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageIAP%E7%94%A8%E6%88%B7%E4%B8%AD%E6%96%AD%E5%81%8F%E7%A7%BB%E8%AE%BE%E7%BD%AE.png" alt="中断偏移设置"></li>
</ul>
<p>2.设置程序编译文件格式为bin</p>
<blockquote>
<p>生成bin文件的命令：<br> fromelf.exe –bin -o ./Flash/Obj/output.bin  ./Flash/Obj/output.axf</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_image%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6bin.png" alt="生成bin文件"></p>
]]></content>
      <categories>
        <category>IAP</category>
      </categories>
      <tags>
        <tag>IAP</tag>
      </tags>
  </entry>
  <entry>
    <title>【RTX5】事件标志组</title>
    <url>/posts/2/</url>
    <content><![CDATA[<h1 id="事件标志组"><a href="#事件标志组" class="headerlink" title="事件标志组"></a>事件标志组</h1><blockquote>
<p>事件标志组是一种实现多任务同步机制。<br>优点：</p>
<ol>
<li>方便RTOS有效管理任务， 实现多任务之间的同步</li>
<li>有效解决中断服务程序和任务之间的同步问题</li>
</ol>
</blockquote>
<h2 id="事件标志API"><a href="#事件标志API" class="headerlink" title="事件标志API"></a>事件标志API</h2><h3 id="1-创建事件标志对象"><a href="#1-创建事件标志对象" class="headerlink" title="1. 创建事件标志对象"></a>1. 创建事件标志对象</h3><pre class="line-numbers language-C"><code class="language-C">原型 
osEventFlagsId_t osEventFlagsNew(const osEventFlagsAttr_t * attr)    
attr    : 事件标志属性   默认为NULL  
Returns : 返回事件ID , 出现错误则返回 NULL
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-设置定的事件标志"><a href="#2-设置定的事件标志" class="headerlink" title="2. 设置定的事件标志"></a>2. 设置定的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型： uint32_t osEventFlagsSet    (    osEventFlagsId_t     ef_id, uint32_t flags)    
ef_id   : 要设置事件的ID
flags   : 指定应设置的标志 ，该标志只能设置0bit - 30bit, 设置最高位则是设置错误代码
Returns : 返回设置后设置事件的标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-清除指定的事件标志"><a href="#3-清除指定的事件标志" class="headerlink" title="3.清除指定的事件标志"></a>3.清除指定的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型: uint32_t osEventFlagsClear    (    osEventFlagsId_t     ef_id, uint32_t     flags)
ef_id      : 要设置事件的ID
flags   : 指定应清除的标志
Returns ：返回清除前的事件标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-获取当前事件标志对象的事件标志"><a href="#4-获取当前事件标志对象的事件标志" class="headerlink" title="4. 获取当前事件标志对象的事件标志"></a>4. 获取当前事件标志对象的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型：uint32_t osEventFlagsGet    (osEventFlagsId_t     ef_id)
ef_id   ： 事件的ID
Returns ： 返回当前事件对象的事件标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="5-等待事件标志"><a href="#5-等待事件标志" class="headerlink" title="5. 等待事件标志"></a>5. 等待事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型：uint32_t osEventFlagsWait    (    osEventFlagsId_t     ef_id,
                                  uint32_t     flags,
                                  uint32_t     options,
                                  uint32_t     timeout 
                                 )    
ef_id   ： 所等待的事件对象
flags   ： 指定等待事件标志
options ： 等待条件
           osFlagsWaitAny        等待任何标志
           osFlagsWaitAll        等待所有标志
           osFlagsNoClear        不要清除已指定要等待的标志，一般用于手动清除

timeout ：系统等待事件标志的时间 ， 如果该值设为osWaitForever该函数将等待无限的
          时间，直到事件标志变为可用。
Returns ：如果等到事件标志则返回该事件标志或者返回错误码，错误码如下：
          osFlagsErrorUnknown(-1)   未指定的错误
          osFlagsErrorTimeout(-2)   在给定的时间内尚未设置等待的标志
          osFlagsErrorResource(-3)  未指定超时时，尚未设置等待的标志
          osFlagsErrorParameter(-4) 参数ef_id无法标识有效的事件标志对象或标志
                                    的最高位设置。
          osFlagsErrorISR      (-6) 该函数不能再中断里使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="6">
<li>删除事件标志对象</li>
</ol>
<pre class="line-numbers language-C"><code class="language-C">原型：osStatus_t osEventFlagsDelete( osEventFlagsId_t     ef_id    ) 
ef_id  : 事件对象
Returns: 状态代码，指示功能的执行状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="7-获取事件对象的名称"><a href="#7-获取事件对象的名称" class="headerlink" title="7. 获取事件对象的名称"></a>7. 获取事件对象的名称</h3><pre class="line-numbers language-C"><code class="language-C">ef_id  : 事件对象
Returns: 事件对象的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="事件标志组使用"><a href="#事件标志组使用" class="headerlink" title="事件标志组使用"></a>事件标志组使用</h2><ol>
<li>两个线程如何使用事件标志组通信示意图<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_image%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%97%B4%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E9%80%9A%E4%BF%A1.PNG" alt=""></li>
</ol>
<h3 id="1-事件标志组使用示例"><a href="#1-事件标志组使用示例" class="headerlink" title="1. 事件标志组使用示例"></a>1. 事件标志组使用示例</h3><pre class="line-numbers language-C"><code class="language-C"> #include "cmsis_os2.h"                      

/*事件标志*/ 
#define FLAGS_MSK1 0x00000001U

/*事件对象*/ 
osEventFlagsId_t evt_id;                        

/*发送事件标志线程ID*/ 
osThreadId_t tid_Thread_EventSender;  
/*接收事件标志线程ID*/           
osThreadId_t tid_Thread_EventReceiver;          

void Thread_EventSender   (void *argument);  
void Thread_EventReceiver (void *argument);     

int Init_Events (void) {
  /*创建事件对象*/
  evt_id = osEventFlagsNew(NULL);
  if (evt_id == NULL) {
    /*线程对象创建失败处理*/
  }

 /*创建发送事件标志线程*/
  tid_Thread_EventSender = osThreadNew(Thread_EventSender, NULL, NULL);
  if (tid_Thread_EventSender == NULL) {
    return(-1);
  }
   /*创建接收事件标志线程*/
  tid_Thread_EventReceiver = osThreadNew(Thread_EventReceiver, NULL, NULL);
  if (tid_Thread_EventReceiver == NULL) {
    return(-1);
  }
  return(0);
}

void Thread_EventSender (void *argument) {

  while (1) {  
    /*设置事件标志*/  
    osEventFlagsSet(evt_id, FLAGS_MSK1);
    /*挂起任务*/
    osThreadYield();                           s
  }
}

void Thread_EventReceiver (void *argument) {
  uint32_t flags;

  while (1) {
    /*阻塞等待接收事件，直到等到该事件标志*/
    flags = osEventFlagsWait(evt_id, FLAGS_MSK1, osFlagsWaitAny, osWaitForever);

    /*根据等到的事件标志来执行相应的动作*/
    switch(flags)
    {
      case EVENT_1:

      break;
      case EVENT_2:

      break;
     default:
      break;
    }
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>嵌入式系统</category>
      </categories>
      <tags>
        <tag>RTX5</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake用法</title>
    <url>/posts/1/</url>
    <content><![CDATA[<h2 id="Cmake基本用法"><a href="#Cmake基本用法" class="headerlink" title="Cmake基本用法"></a>Cmake基本用法</h2><ul>
<li>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)</li>
</ul>
<blockquote>
<p>指定Cmake最低版本需求 2.83</p>
</blockquote>
<ul>
<li>project(&lt;PROJECT-NAME&gt;)</li>
</ul>
<blockquote>
<p>指定项目名称  例如：PROJECT(hello)</p>
</blockquote>
<ul>
<li>AUX_SOURCE_DIRECTORY(&lt;dir&gt;   &lt;variable&gt;)</li>
</ul>
<blockquote>
<p>添加某路径下的所有源文件，并将该路径用变量来表示</p>
</blockquote>
<ul>
<li>ADD_EXECUTABLE(生成可执行文件的名字  变量)</li>
</ul>
<blockquote>
<p>ADD_EXECUTABLE(hello ${SRC_LIST})<br>将变量SRC_LIST表示路径下源文件编译，并生成可执行文件hello</p>
</blockquote>
<h2 id="同一目录，多文件"><a href="#同一目录，多文件" class="headerlink" title="同一目录，多文件"></a>同一目录，多文件</h2><blockquote>
<p>./Demo<br>|<br>+—-main.cc<br>|<br>+—-function.c<br>|<br>+—-function.h</p>
</blockquote>
<p>这种CmakeLists.txt写法如下：</p>
<blockquote>
<p>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)<br>project(Demo)<br>AUX_SOURCE_DIRECTORY(./Demo  SRC)<br>ADD_EXECUTABLE(function ${SRC})</p>
</blockquote>
<h2 id="多目录，多文件"><a href="#多目录，多文件" class="headerlink" title="多目录，多文件"></a>多目录，多文件</h2><blockquote>
<p>./Demo<br>|<br>+—main.cc<br>|<br>+—function/<br>|<br>+—function.cc<br>|<br>+—function.h</p>
</blockquote>
<p>主目录 CmakeLists.txt写法如下：</p>
<blockquote>
<p>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)<br>PROJECT(Demo)<br>AUX_SOURCE_DIRECTORY(./Demo SRC)<br>subdirectory(function)<br>ADD_EXECUTABLE(Demo ${SRC})</p>
</blockquote>
<p>子目录 CmakeLists.txt写法如下：</p>
<blockquote>
<p>AUX_SOURCE_DIRECTORY(. SUB_SRC)</p>
</blockquote>
<ul>
<li>find_package</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型 ：find_package(<package> [version] [EXACT] [QUIET] [MODULE]
            [REQUIRED] [[COMPONENTS] [components...]]
            [OPTIONAL_COMPONENTS components...]
            [NO_POLICY_SCOPE])
 <package>   :指定查找的软件包
 [QUIET]     :如果找不到软件包，该选项将禁用警告消息
 [MODULE]    :禁用下面记录的第二个签名
 [REQUIRED]  :其含义是指是否是工程必须的，表示如果没有找到的
              话，cmake的过程会终止，并发出警告信息
 [COMPONENTS]:在REQUIRED选项之后，或者如果没有指定REQUIRED选项
              但指定了COMPONENTS选项，在它们的后面可以列出一包
              相关(依赖)的部件清单。
示例 ： find_package(Protobuf REQUIRED)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>target_link_libraries</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型： target_link_libraries(<target> [item1] [item2] [...]
                         [[debug|optimized|general] <item>] ...)
用法： target_link_libraries(projectname  Libname);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>find_package 和 target_link_libraries示例</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">cmake_minimum_required(VERSION 2.8.3)
project(VMSClient)
set(CMAKE_AUTOMOC ON)
set(CMAKE_BUILD_TYPE RELEASE)
find_package(catkin REQUIRED COMPONENTS
        roscpp
        sensor_msgs
        std_msgs
        aisimba_msgs
        )

catkin_package()
find_package(Qt5Widgets REQUIRED)
find_package(Qt5Core REQUIRED)
find_package(Qt5Gui REQUIRED)
find_package(Qt5WebSockets REQUIRED)
find_package(Qt5Network REQUIRED)
find_package(Protobuf REQUIRED)

if (PROTOBUF_FOUND)
    message(STATUS "protobuf library found")
else ()
    message(FATAL_ERROR "protobuf library is needed but cant be found")
endif ()

include_directories(
        include
        ${catkin_INCLUDE_DIRS}
)

include_directories(${PROTOBUF_INCLUDE_DIRS})
include_directories(${PROJECT_SOURCE_DIR}/include)
include_directories(${PROJECT_SOURCE_DIR}/proto_src)

file(GLOB_RECURSE SRC src/*.c src/*.cpp proto_src/*.cc)
file(GLOB_RECURSE INC include/*.h include/*.hpp proto_src/*.h)

add_executable(${PROJECT_NAME}_node ${INC} ${SRC})
add_definitions(-std=c++11 -g -O3 -Wno-deprecated -Wno-dev)
add_dependencies(${PROJECT_NAME}_node ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})

target_link_libraries(${PROJECT_NAME}_node
        ${catkin_LIBRARIES}
        ${PROTOBUF_LIBRARIES}
        Qt5::Widgets
        Qt5::Core
        Qt5::Gui
        Qt5::WebSockets
        Qt5::Network
        glog
        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Cmake</category>
      </categories>
      <tags>
        <tag>自动化管理工程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Emwin】显示字体</title>
    <url>/posts/5/</url>
    <content><![CDATA[<h2 id="官方demo"><a href="#官方demo" class="headerlink" title="官方demo"></a>官方demo</h2><pre class="line-numbers language-C"><code class="language-C">#include "GUI.h"

#define RECOMMENDED_MEMPRY (1024L * 5)

void MainTask(void)
{
    int xPos;
    int yPos;
    int xSize;
    int i;
    i = 0;

    GUI_Init();

    if (GUI_ALLOC_GetNumFreeBytes() < RECOMMENDED_MEMPRY)
    {
        GUI_ErrorOut("not enough memory available");
        return;
    }

    xPos = LCD_GetXSize() / 2;
    yPos = LCD_GetYSize() / 2;

    GUI_SetTextMode(GUI_TM_REV);
    GUI_SetFont(GUI_FONT_20F_ASCII);
    GUI_DispStringHCenterAt("Hello world!", xPos, yPos);

    GUI_SetFont(GUI_FONT_D24X32);
    xSize = GUI_GetStringDistX("0000");
    xPos -= xSize / 2;
    yPos += 24 + 10;

    while (1)
    {
        GUI_DispDecAt(i ++, xPos, yPos, 4);
        if (i > 9999)
        {
            i = 0;
        }
    }

}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><ul>
<li>GUI_SetTextMode</li>
</ul>
<blockquote>
<p>原    型：int GUI_SetTextMode(int TextMode)<br>函数说明：设置文本模式<br>参    数：<br>      GUI_TEXTMODE_NORMAL      文本正常显示。这是默认设置;这个值等于0<br>       GUI_TEXTMODE_REV         文本反向显示。(实测背景色相反)<br>       GUI_TEXTMODE_TRANS       文本显示为透明<br>       GUI_TEXTMODE_XOR         文本反转背景</p>
</blockquote>
<ul>
<li>GUI_SetFont</li>
</ul>
<blockquote>
<p>原    型：const GUI_FONT * GUI_SetFont(const GUI_FONT * pNewFont)<br>函数说明：设置用于文本输出的字体<br>参    数：<br>         pNewFont:指向要选择和使用的字体的指针,例如GUI_FONT_20F_ASCII</p>
</blockquote>
<ul>
<li>GUI_DispStringHCenterAt</li>
</ul>
<blockquote>
<p>原    型：void GUI_DispStringHCenterAt(const char * s, int x, int y);<br>函数说明：显示作为参数传递的字符串在指定位置水平居中在当前窗口中使用当前字体<br>参    数：<br>        s:要显示的字符串<br>        x:显示位置横坐标<br>        y:显示位置纵坐标</p>
</blockquote>
<ul>
<li>GUI_GetStringDistX</li>
</ul>
<blockquote>
<p>原    型：int GUI_GetStringDistX(const char * s);<br>函数说明：返回用于以当前选定字体显示指定字符串的X-size<br>参    数：<br>        s:指定字符串</p>
</blockquote>
<ul>
<li>GUI_DispDecAt</li>
</ul>
<blockquote>
<p>原    型：void GUI_DispDecAt(I32 v, I16P x, I16P y, U8 Len);<br>函数说明：以十进制形式显示具有指定字符数的值，使用当前字体在当前窗口中的位置。<br>参    数：<br>        v  :显示的十进制的值<br>        x  :显示位置的横坐标<br>        y  :显示位置的纵坐标<br>        len:显示的最大位数</p>
</blockquote>
]]></content>
      <categories>
        <category>Emwin</category>
      </categories>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/1243066710/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
