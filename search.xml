<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【RTX5】事件标志组</title>
    <url>/posts/4278564288/</url>
    <content><![CDATA[<h1 id="事件标志组"><a href="#事件标志组" class="headerlink" title="事件标志组"></a>事件标志组</h1><blockquote>
<p>事件标志组是一种实现多任务同步机制。<br>优点：</p>
<ol>
<li>方便RTOS有效管理任务， 实现多任务之间的同步</li>
<li>有效解决中断服务程序和任务之间的同步问题</li>
</ol>
</blockquote>
<h2 id="事件标志API"><a href="#事件标志API" class="headerlink" title="事件标志API"></a>事件标志API</h2><h3 id="1-创建事件标志对象"><a href="#1-创建事件标志对象" class="headerlink" title="1. 创建事件标志对象"></a>1. 创建事件标志对象</h3><pre class="line-numbers language-C"><code class="language-C">原型 
osEventFlagsId_t osEventFlagsNew(const osEventFlagsAttr_t * attr)    
attr    : 事件标志属性   默认为NULL  
Returns : 返回事件ID , 出现错误则返回 NULL
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-设置定的事件标志"><a href="#2-设置定的事件标志" class="headerlink" title="2. 设置定的事件标志"></a>2. 设置定的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型： uint32_t osEventFlagsSet    (    osEventFlagsId_t     ef_id, uint32_t flags)    
ef_id   : 要设置事件的ID
flags   : 指定应设置的标志 ，该标志只能设置0bit - 30bit, 设置最高位则是设置错误代码
Returns : 返回设置后设置事件的标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-清除指定的事件标志"><a href="#3-清除指定的事件标志" class="headerlink" title="3.清除指定的事件标志"></a>3.清除指定的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型: uint32_t osEventFlagsClear    (    osEventFlagsId_t     ef_id, uint32_t     flags)
ef_id      : 要设置事件的ID
flags   : 指定应清除的标志
Returns ：返回清除前的事件标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-获取当前事件标志对象的事件标志"><a href="#4-获取当前事件标志对象的事件标志" class="headerlink" title="4. 获取当前事件标志对象的事件标志"></a>4. 获取当前事件标志对象的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型：uint32_t osEventFlagsGet    (osEventFlagsId_t     ef_id)
ef_id   ： 事件的ID
Returns ： 返回当前事件对象的事件标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="5-等待事件标志"><a href="#5-等待事件标志" class="headerlink" title="5. 等待事件标志"></a>5. 等待事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型：uint32_t osEventFlagsWait    (    osEventFlagsId_t     ef_id,
                                  uint32_t     flags,
                                  uint32_t     options,
                                  uint32_t     timeout 
                                 )    
ef_id   ： 所等待的事件对象
flags   ： 指定等待事件标志
options ： 等待条件
           osFlagsWaitAny        等待任何标志
           osFlagsWaitAll        等待所有标志
           osFlagsNoClear        不要清除已指定要等待的标志，一般用于手动清除

timeout ：系统等待事件标志的时间 ， 如果该值设为osWaitForever该函数将等待无限的
          时间，直到事件标志变为可用。
Returns ：如果等到事件标志则返回该事件标志或者返回错误码，错误码如下：
          osFlagsErrorUnknown(-1)   未指定的错误
          osFlagsErrorTimeout(-2)   在给定的时间内尚未设置等待的标志
          osFlagsErrorResource(-3)  未指定超时时，尚未设置等待的标志
          osFlagsErrorParameter(-4) 参数ef_id无法标识有效的事件标志对象或标志
                                    的最高位设置。
          osFlagsErrorISR      (-6) 该函数不能再中断里使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="6">
<li>删除事件标志对象</li>
</ol>
<pre class="line-numbers language-C"><code class="language-C">原型：osStatus_t osEventFlagsDelete( osEventFlagsId_t     ef_id    ) 
ef_id  : 事件对象
Returns: 状态代码，指示功能的执行状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="7-获取事件对象的名称"><a href="#7-获取事件对象的名称" class="headerlink" title="7. 获取事件对象的名称"></a>7. 获取事件对象的名称</h3><pre class="line-numbers language-C"><code class="language-C">ef_id  : 事件对象
Returns: 事件对象的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="事件标志组使用"><a href="#事件标志组使用" class="headerlink" title="事件标志组使用"></a>事件标志组使用</h2><ol>
<li>两个线程如何使用事件标志组通信示意图<br><img src="http://q3l3oiuxr.bkt.clouddn.com/%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%97%B4%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E9%80%9A%E4%BF%A1.PNG" alt="logo"></li>
</ol>
<h3 id="1-事件标志组使用示例"><a href="#1-事件标志组使用示例" class="headerlink" title="1. 事件标志组使用示例"></a>1. 事件标志组使用示例</h3><pre class="line-numbers language-C"><code class="language-C"> #include "cmsis_os2.h"                      

/*事件标志*/ 
#define FLAGS_MSK1 0x00000001U

/*事件对象*/ 
osEventFlagsId_t evt_id;                        

/*发送事件标志线程ID*/ 
osThreadId_t tid_Thread_EventSender;  
/*接收事件标志线程ID*/           
osThreadId_t tid_Thread_EventReceiver;          

void Thread_EventSender   (void *argument);  
void Thread_EventReceiver (void *argument);     

int Init_Events (void) {
  /*创建事件对象*/
  evt_id = osEventFlagsNew(NULL);
  if (evt_id == NULL) {
    /*线程对象创建失败处理*/
  }

 /*创建发送事件标志线程*/
  tid_Thread_EventSender = osThreadNew(Thread_EventSender, NULL, NULL);
  if (tid_Thread_EventSender == NULL) {
    return(-1);
  }
   /*创建接收事件标志线程*/
  tid_Thread_EventReceiver = osThreadNew(Thread_EventReceiver, NULL, NULL);
  if (tid_Thread_EventReceiver == NULL) {
    return(-1);
  }
  return(0);
}

void Thread_EventSender (void *argument) {

  while (1) {  
    /*设置事件标志*/  
    osEventFlagsSet(evt_id, FLAGS_MSK1);
    /*挂起任务*/
    osThreadYield();                           s
  }
}

void Thread_EventReceiver (void *argument) {
  uint32_t flags;

  while (1) {
    /*阻塞等待接收事件，直到等到该事件标志*/
    flags = osEventFlagsWait(evt_id, FLAGS_MSK1, osFlagsWaitAny, osWaitForever);

    /*根据等到的事件标志来执行相应的动作*/
    switch(flags)
    {
      case EVENT_1:

      break;
      case EVENT_2:

      break;
     default:
      break;
    }
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>嵌入式系统</category>
      </categories>
      <tags>
        <tag>RTX5</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake用法</title>
    <url>/posts/4278564289/</url>
    <content><![CDATA[<h2 id="Cmake基本用法"><a href="#Cmake基本用法" class="headerlink" title="Cmake基本用法"></a>Cmake基本用法</h2><ul>
<li>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)</li>
</ul>
<blockquote>
<p>指定Cmake最低版本需求 2.83</p>
</blockquote>
<ul>
<li>project(&lt;PROJECT-NAME&gt;)</li>
</ul>
<blockquote>
<p>指定项目名称  例如：PROJECT(hello)</p>
</blockquote>
<ul>
<li>AUX_SOURCE_DIRECTORY(&lt;dir&gt;   &lt;variable&gt;)</li>
</ul>
<blockquote>
<p>添加某路径下的所有源文件，并将该路径用变量来表示</p>
</blockquote>
<ul>
<li>ADD_EXECUTABLE(生成可执行文件的名字  变量)</li>
</ul>
<blockquote>
<p>ADD_EXECUTABLE(hello ${SRC_LIST})<br>将变量SRC_LIST表示路径下源文件编译，并生成可执行文件hello</p>
</blockquote>
<h2 id="同一目录，多文件"><a href="#同一目录，多文件" class="headerlink" title="同一目录，多文件"></a>同一目录，多文件</h2><blockquote>
<p>./Demo<br>|<br>+—-main.cc<br>|<br>+—-function.c<br>|<br>+—-function.h</p>
</blockquote>
<p>这种CmakeLists.txt写法如下：</p>
<blockquote>
<p>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)<br>project(Demo)<br>AUX_SOURCE_DIRECTORY(./Demo  SRC)<br>ADD_EXECUTABLE(function ${SRC})</p>
</blockquote>
<h2 id="多目录，多文件"><a href="#多目录，多文件" class="headerlink" title="多目录，多文件"></a>多目录，多文件</h2><blockquote>
<p>./Demo<br>|<br>+—main.cc<br>|<br>+—function/<br>|<br>+—function.cc<br>|<br>+—function.h</p>
</blockquote>
<p>主目录 CmakeLists.txt写法如下：</p>
<blockquote>
<p>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)<br>PROJECT(Demo)<br>AUX_SOURCE_DIRECTORY(./Demo SRC)<br>subdirectory(function)<br>ADD_EXECUTABLE(Demo ${SRC})</p>
</blockquote>
<p>子目录 CmakeLists.txt写法如下：</p>
<blockquote>
<p>AUX_SOURCE_DIRECTORY(. SUB_SRC)</p>
</blockquote>
<ul>
<li>find_package</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型 ：find_package(<package> [version] [EXACT] [QUIET] [MODULE]
            [REQUIRED] [[COMPONENTS] [components...]]
            [OPTIONAL_COMPONENTS components...]
            [NO_POLICY_SCOPE])
 <package>   :指定查找的软件包
 [QUIET]     :如果找不到软件包，该选项将禁用警告消息
 [MODULE]    :禁用下面记录的第二个签名
 [REQUIRED]  :其含义是指是否是工程必须的，表示如果没有找到的
              话，cmake的过程会终止，并发出警告信息
 [COMPONENTS]:在REQUIRED选项之后，或者如果没有指定REQUIRED选项
              但指定了COMPONENTS选项，在它们的后面可以列出一包
              相关(依赖)的部件清单。
示例 ： find_package(Protobuf REQUIRED)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>target_link_libraries</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型： target_link_libraries(<target> [item1] [item2] [...]
                         [[debug|optimized|general] <item>] ...)
用法： target_link_libraries(projectname  Libname);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>find_package 和 target_link_libraries示例</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">cmake_minimum_required(VERSION 2.8.3)
project(VMSClient)
set(CMAKE_AUTOMOC ON)
set(CMAKE_BUILD_TYPE RELEASE)
find_package(catkin REQUIRED COMPONENTS
        roscpp
        sensor_msgs
        std_msgs
        aisimba_msgs
        )

catkin_package()
find_package(Qt5Widgets REQUIRED)
find_package(Qt5Core REQUIRED)
find_package(Qt5Gui REQUIRED)
find_package(Qt5WebSockets REQUIRED)
find_package(Qt5Network REQUIRED)
find_package(Protobuf REQUIRED)

if (PROTOBUF_FOUND)
    message(STATUS "protobuf library found")
else ()
    message(FATAL_ERROR "protobuf library is needed but cant be found")
endif ()

include_directories(
        include
        ${catkin_INCLUDE_DIRS}
)

include_directories(${PROTOBUF_INCLUDE_DIRS})
include_directories(${PROJECT_SOURCE_DIR}/include)
include_directories(${PROJECT_SOURCE_DIR}/proto_src)

file(GLOB_RECURSE SRC src/*.c src/*.cpp proto_src/*.cc)
file(GLOB_RECURSE INC include/*.h include/*.hpp proto_src/*.h)

add_executable(${PROJECT_NAME}_node ${INC} ${SRC})
add_definitions(-std=c++11 -g -O3 -Wno-deprecated -Wno-dev)
add_dependencies(${PROJECT_NAME}_node ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})

target_link_libraries(${PROJECT_NAME}_node
        ${catkin_LIBRARIES}
        ${PROTOBUF_LIBRARIES}
        Qt5::Widgets
        Qt5::Core
        Qt5::Gui
        Qt5::WebSockets
        Qt5::Network
        glog
        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Cmake</category>
      </categories>
      <tags>
        <tag>自动化管理工程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Emwin】显示字体</title>
    <url>/posts/4278564287/</url>
    <content><![CDATA[<h2 id="官方demo"><a href="#官方demo" class="headerlink" title="官方demo"></a>官方demo</h2><pre class="line-numbers language-C"><code class="language-C">#include "GUI.h"

#define RECOMMENDED_MEMPRY (1024L * 5)

void MainTask(void)
{
    int xPos;
    int yPos;
    int xSize;
    int i;
    i = 0;

    GUI_Init();

    if (GUI_ALLOC_GetNumFreeBytes() < RECOMMENDED_MEMPRY)
    {
        GUI_ErrorOut("not enough memory available");
        return;
    }

    xPos = LCD_GetXSize() / 2;
    yPos = LCD_GetYSize() / 2;

    GUI_SetTextMode(GUI_TM_REV);
    GUI_SetFont(GUI_FONT_20F_ASCII);
    GUI_DispStringHCenterAt("Hello world!", xPos, yPos);

    GUI_SetFont(GUI_FONT_D24X32);
    xSize = GUI_GetStringDistX("0000");
    xPos -= xSize / 2;
    yPos += 24 + 10;

    while (1)
    {
        GUI_DispDecAt(i ++, xPos, yPos, 4);
        if (i > 9999)
        {
            i = 0;
        }
    }

}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><ul>
<li>GUI_SetTextMode</li>
</ul>
<blockquote>
<p>原    型：int GUI_SetTextMode(int TextMode)<br>函数说明：设置文本模式<br>参    数：<br>      GUI_TEXTMODE_NORMAL      文本正常显示。这是默认设置;这个值等于0<br>       GUI_TEXTMODE_REV         文本反向显示。(实测背景色相反)<br>       GUI_TEXTMODE_TRANS       文本显示为透明<br>       GUI_TEXTMODE_XOR         文本反转背景</p>
</blockquote>
<ul>
<li>GUI_SetFont</li>
</ul>
<blockquote>
<p>原    型：const GUI_FONT * GUI_SetFont(const GUI_FONT * pNewFont)<br>函数说明：设置用于文本输出的字体<br>参    数：<br>         pNewFont:指向要选择和使用的字体的指针,例如GUI_FONT_20F_ASCII</p>
</blockquote>
<ul>
<li>GUI_DispStringHCenterAt</li>
</ul>
<blockquote>
<p>原    型：void GUI_DispStringHCenterAt(const char * s, int x, int y);<br>函数说明：显示作为参数传递的字符串在指定位置水平居中在当前窗口中使用当前字体<br>参    数：<br>        s:要显示的字符串<br>        x:显示位置横坐标<br>        y:显示位置纵坐标</p>
</blockquote>
<ul>
<li>GUI_GetStringDistX</li>
</ul>
<blockquote>
<p>原    型：int GUI_GetStringDistX(const char * s);<br>函数说明：返回用于以当前选定字体显示指定字符串的X-size<br>参    数：<br>        s:指定字符串</p>
</blockquote>
<ul>
<li>GUI_DispDecAt</li>
</ul>
<blockquote>
<p>原    型：void GUI_DispDecAt(I32 v, I16P x, I16P y, U8 Len);<br>函数说明：以十进制形式显示具有指定字符数的值，使用当前字体在当前窗口中的位置。<br>参    数：<br>        v  :显示的十进制的值<br>        x  :显示位置的横坐标<br>        y  :显示位置的纵坐标<br>        len:显示的最大位数</p>
</blockquote>
]]></content>
      <categories>
        <category>Emwin</category>
      </categories>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/1243066710/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
