<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【FPGA】---uart回环实验</title>
    <url>/posts/64/</url>
    <content><![CDATA[<h1 id="串口接收数据回传"><a href="#串口接收数据回传" class="headerlink" title="串口接收数据回传"></a>串口接收数据回传</h1><h2 id="程序整体框架"><a href="#程序整体框架" class="headerlink" title="程序整体框架"></a>程序整体框架</h2><ul>
<li>uart_top 顶层模块</li>
<li>串口接收模块</li>
<li>串口发送模块  </li>
</ul>
<h3 id="UART-串口接收数据模块"><a href="#UART-串口接收数据模块" class="headerlink" title="UART 串口接收数据模块"></a>UART 串口接收数据模块</h3><ul>
<li>uart 串口接收模块端口<blockquote>
<p>input  clk<br>input  rst_n<br>input  uart_rx_data<br>output [7 : 0] uart_data<br>output         uart_done</p>
</blockquote>
</li>
</ul>
<ul>
<li>uart 串口接收模块编写流程</li>
</ul>
<ol>
<li><p>接收数据时，当数据线被拉低时，即代表开始接收数据(下降沿检测)\</p>
<pre><code>主要是对 uart_rx_data端口在连续两个周期缓存两次，主要写法如下：

assign  start_flag = uart_rx_d1 &amp; (~uart_rx_d0);
/*捕获接收信号 ---- 下降沿*/
always @(posedge clk or negedge rst_n)begin
 if(!rst_n)begin
 uart_rx_d0 &lt;= 1&#39;b0;
 uart_rx_d1 &lt;= 1&#39;b0;
 end
 else begin
    uart_rx_d0 &lt;= uart_rx_data;
    uart_rx_d1 &lt;= uart_rx_d0;    
 end
end</code></pre></li>
<li><p>当进入接收状态时，即在start_flag == 1时将rx_flag置一，当接收数据<br>个数为9时及cnt_clk计数器计数值处于BPS_CNT/2时，代表该串口接收数据结束.</p>
<pre><code>/*开始信号到来,进入接收流程*/
always @(posedge clk or negedge rst_n)begin
if(!rst_n)
  rx_flag &lt;= 1&#39;b0;
else begin
  if(start_flag)
    rx_flag &lt;= 1&#39;b1;
   else if((rx_cnt == 4&#39;d9) &amp;&amp; (clk_cnt == BPS_CNT/2)) /*接收9个bit数据*/
    rx_flag &lt;= 1&#39;b0;
   else
    rx_flag &lt;= rx_flag;
end
end</code></pre></li>
<li><p>接收数据计数器和时钟计数器,主要是根据rx_flag接收信号对clk_cnt<br>计数，当clk_cnt &lt; BPS_CNT(接收一个bit所需要的时间),clk_cnt ++;<br>当clk_cnt &gt;= BPS_CNT时，认为一个bit已经接收完毕，同时clk_cnt清零。</p>
<pre><code>always @(posedge clk or negedge rst_n)begin
  if(!rst_n) begin
   clk_cnt &lt;= 16&#39;d0;
   rx_cnt  &lt;= 4&#39;d0 ;
  end 
  else if(rx_flag)begin
     if(clk_cnt &lt; BPS_CNT - 1)begin
        clk_cnt &lt;= clk_cnt + 1&#39;d1;
        rx_cnt  &lt;= rx_cnt;
     end
     else begin
       clk_cnt &lt;= 16&#39;d0;
       rx_cnt &lt;= rx_cnt + 1&#39;d1;
     end
  end
  else begin
     clk_cnt &lt;= 16&#39;d0;
     rx_cnt  &lt;= 4&#39;d0;
  end
end</code></pre></li>
<li><p>将接收到的数据缓存起来,当处于接收状态(rx_flag=1)并clk_cnt == BPS_CNT / 2时，此时数据处于较稳定状态，根据rx_cnt来对相应数据进行存储。</p>
<pre><code>/*将接收的数据寄存起来*/
always @(posedge clk or negedge rst_n)begin
if(!rst_n)
rxdata &lt;= 8&#39;d0;
else if(rx_flag)begin
   if(clk_cnt == BPS_CNT / 2)begin
      /*根据数据计数器，将接收到的数据存入相应的地方*/
      case(rx_cnt)
      4&#39;d1: rxdata[0] &lt;= uart_rx_d1;
      4&#39;d2: rxdata[1] &lt;= uart_rx_d1;
      4&#39;d3: rxdata[2] &lt;= uart_rx_d1;
      4&#39;d4: rxdata[3] &lt;= uart_rx_d1;
      4&#39;d5: rxdata[4] &lt;= uart_rx_d1;
      4&#39;d6: rxdata[5] &lt;= uart_rx_d1;
      4&#39;d7: rxdata[6] &lt;= uart_rx_d1;
     4&#39;d8: rxdata[7] &lt;= uart_rx_d1;
      default: ;
      endcase

   end

   else 
   rxdata &lt;= rxdata;
 end
 else 
   rxdata &lt;= 8&#39;d0;
end</code></pre></li>
<li><p>将缓存的数据发送到串口发送端,当rx_cnt=9时，即一个帧数据接收完毕，此时将接收<br>完一帧数据标志rx_done置一，同时将接收的数据缓存到uart_data,发送给串口发送模块。</p>
<pre><code>/*置接收完成标志，并将数据缓存出去*/
always @(posedge clk or negedge rst_n)begin
 if(!rst_n )begin
 uart_data &lt;= 8&#39;d0;
 uart_rx_done &lt;= 1&#39;b0;
 end
 else if(rx_cnt == 4&#39;d9)begin
    uart_data &lt;= rxdata;
    uart_rx_done &lt;= 1&#39;b1;
 end
 else begin
    uart_data &lt;= 8&#39;d0;
    uart_rx_done &lt;= 1&#39;b0;
 end 
end</code></pre></li>
</ol>
<h3 id="串口发送数据模块"><a href="#串口发送数据模块" class="headerlink" title="串口发送数据模块"></a>串口发送数据模块</h3><ul>
<li><p>uart 串口tx 端口</p>
<blockquote>
<p>input clk<br>input rst_n<br>input         uart_tx_flag<br>input [7: 0]  uart_data<br>output        uart_tx_data</p>
</blockquote>
</li>
<li><p>UART 串口发送数据流程</p>
</li>
</ul>
<ol>
<li><p>捕获 uart_tx_flag接收完成信号，通过对uart_tx_flag缓存两个周期，检测上升沿信号,将发送使能信号是否置一。</p>
<pre><code>reg uart_tx_d0;
reg uart_tx_d1;                      
wire   en_flag;
assign en_flag = uart_tx_d0 &amp; (~uart_tx_d1);
/*接收到串口发送信号， 进入发送过程， 上升沿检测*/
always @(posedge clk or negedge rst_n) begin
if(!rst_n)begin
uart_tx_d0 &lt;= 1&#39;b0;
uart_tx_d1 &lt;= 1&#39;b0;
end
else begin
  uart_tx_d0 &lt;= uart_tx_flag;
  uart_tx_d1 &lt;= uart_tx_d0;
end
end</code></pre></li>
<li><p>当发送使能信号en_flag = 1时，tx_data缓存串口接收发送过来的数据uart_data，当发送的9个bit后，即代表串口发送完一帧数据。</p>
<pre><code>/*进入发送过程, 缓存串口接收端口发送的数据*/
always @(posedge clk or negedge rst_n) begin
if(!rst_n)begin
  tx_flag &lt;= 1&#39;d0;
  tx_data &lt;= 8&#39;d0;
end
else begin
  if(en_flag)begin
      tx_flag &lt;= 1&#39;b1;
      tx_data &lt;= uart_data;
   end
   else if(tx_cnt == 4&#39;d9 &amp;&amp; clk_cnt == (BSP_CNT / 2)  )begin
   tx_flag &lt;= 1&#39;b0;
  tx_data &lt;= 8&#39;d0;
   end
   else begin
   tx_data &lt;= tx_data;
    tx_flag &lt;= tx_flag;
  end
end   
end</code></pre><ol start="3">
<li>串口发送时钟计数器和发送数据计数器， 在发送状态中，当clk_cnt &lt; BPS_CNT -1,<br>clk_cnt ++ , 当clk_cnt &gt;= BPS_CNT - 1时,即串口成功发送一个bit。</li>
</ol>
<pre><code>always @(posedge clk or negedge rst_n)begin
 if(!rst_n)begin
 clk_cnt &lt;= 16&#39;d0;
 tx_cnt  &lt;= 4&#39;d0;
 end
 else begin
   if(tx_flag) begin //发送信号到来时，开始计数
       if(clk_cnt &lt;= BSP_CNT - 1)begin
          clk_cnt &lt;= clk_cnt + 1&#39;d1;
          tx_cnt  &lt;= tx_cnt;
       end
       else begin   //当计数到达BSP_CNT时，即接收完一个bit
          clk_cnt &lt;= 16&#39;d0;
         tx_cnt  &lt;= tx_cnt + 1&#39;d1;
        end
   end
   else begin 
      clk_cnt &lt;= 16&#39;d0;
      tx_cnt  &lt;= 4&#39;d0;
    end
end
end</code></pre><ol start="4">
<li>将缓存下的并行数据转化为串行数据发送出去</li>
</ol>
<pre><code>always @(posedge clk or negedge rst_n)begin
if(!rst_n)begin
uart_tx_data &lt;= 1&#39;d1;
end
else if(tx_flag)begin
  case(tx_cnt)
     4&#39;d0: uart_tx_data &lt;= 1&#39;b0;         //起始位 
     4&#39;d1: uart_tx_data &lt;= tx_data[0];
     4&#39;d2: uart_tx_data &lt;= tx_data[1];
      4&#39;d3: uart_tx_data &lt;= tx_data[2];
      4&#39;d4: uart_tx_data &lt;= tx_data[3];
      4&#39;d5: uart_tx_data &lt;= tx_data[4];
      4&#39;d6: uart_tx_data &lt;= tx_data[5];
      4&#39;d7: uart_tx_data &lt;= tx_data[6];
      4&#39;d8: uart_tx_data &lt;= tx_data[7];
     4&#39;d9: uart_tx_data &lt;= 1&#39;b1;
     default: ;
   endcase 
end
else 
/*这将uart_tx_data置是为数据发送完毕后能再次进入串口接收*/ 
uart_tx_data &lt;= 1&#39;b1;  
end</code></pre></li>
</ol>
<h3 id="顶层模块"><a href="#顶层模块" class="headerlink" title="顶层模块"></a>顶层模块</h3><p>  顶层模块主要是对uart接收模块和uart发送模块例化</p>
<pre><code>module uart_top(

  input clk,
  input rst_n,

  input  uart_rx,

  output uart_tx

);

parameter CLK_FREQ = 50000000;
parameter UART_BPS = 115200;


wire         uart_en_w;
wire [7 : 0] uart_data_w;
wire         clk_1m_w;

ip_pll    ip_pll_inst (
    .inclk0 ( clk ),
    .c0 ( clk_1m_w )
    );



uart_rx #(                          //串口接收模块
    .CLK_FREQ       (CLK_FREQ),       //设置系统时钟频率
    .UART_BPS       (UART_BPS))       //设置串口接收波特率
u_uart_x(                 
    .clk        (clk), 
    .rst_n      (rst_n),

    .uart_rx_data       (uart_rx),
    .uart_rx_done       (uart_en_w),
    .uart_data          (uart_data_w)
    );
uart_tx  #(
    .CLK_FREQ  (CLK_FREQ),
    .UART_BPS  (UART_BPS))
 u_uart_tx(
    .clk          (clk),
    .rst_n        (rst_n),

    .uart_tx_flag (uart_en_w),
    .uart_data    (uart_data_w),
    .uart_tx_data (uart_tx)
);


endmodule
</code></pre>]]></content>
      <categories>
        <category>FPGA</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title>【Emwin】自定义按键</title>
    <url>/posts/0000000b/</url>
    <content><![CDATA[<h2 id="自定义按键"><a href="#自定义按键" class="headerlink" title="自定义按键"></a>自定义按键</h2><blockquote>
<p>Emwin中按键控件的本质也是窗口，一般有系统默认的回调函数，只是被封装了，用户看不到，不像我们使用窗口或者框架窗口的时候还需要专门的设置回调函数。当你想修改按键控件的一些外观时，这就需要我们使用WM_SetCallback设置按键控件的回调函数，并且在回调函数做出相应的修改。</p>
</blockquote>
<h3 id="自定义创建步骤"><a href="#自定义创建步骤" class="headerlink" title="自定义创建步骤"></a>自定义创建步骤</h3><ol>
<li>创建按键控件</li>
</ol>
<pre class="line-numbers language-C"><code class="language-C">BUTTON_Handle BUTTON_CreateEx( int x0,         /*控件最左侧的像素 （在父坐标中）*/
                               int y0,         /*控件最顶端的像素 （在父坐标中）*/
                               int  xSize,     /*控件的水平尺寸 （以像素为单位）*/
                               int ySize,      /*控件的垂直尺寸 （以像素为单位）*/
                               WM_HWIN hParent,/*按钮控件大的父窗口*/
                               int WinFlags,   /*窗口创建标记*/
                               int  ExFlags,   /*预留*/
                               int Id);        /*窗口ID*/

hWin = BUTTON_CreateEx(0,0, 100, 100, 0, WM_CF_SHOW, 0 , 0, GUI_ID_BUTTON0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li>设置按键回调函数</li>
</ol>
<pre class="line-numbers language-C"><code class="language-C">WM_SetCallback(hWin, _cbButtonback);
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ol start="3">
<li>重写按键的回调函数</li>
</ol>
<pre class="line-numbers language-C"><code class="language-C">/* 重写按键的回调函数 */

static void _cbButtonback(WM_MESSAGE* pMsg)
{
    WM_HWIN hWin;
    hWin = pMsg->hWin;

    switch (pMsg->MsgId)
    {
        /*按键控件重绘*/
    case WM_PAINT:
         /*按键按下时, 绘制按键的外观*/
        if (BUTTON_IsPressed(hWin)) 
        {
            GUI_SetColor(GUI_DARKGRAY);
            /*绘制抗锯齿填充的圆*/
            GUI_AA_FillCircle(100 * MAG, 0, 72 * MAG);
            GUI_SetBkColor(GUI_DARKGRAY);
            GUI_SetColor(GUI_WHITE);
            GUI_DrawBitmap(&bmReturn, 40, 5);
        }
        else
        {
              /*按键未按下时, 绘制按键的外观*/
            GUI_SetColor(GUI_STCOLOR_LIGHTBLUE);
            GUI_AA_FillCircle(100 * MAG, 0, 72 * MAG);
            GUI_SetBkColor(GUI_STCOLOR_LIGHTBLUE);
            GUI_SetColor(GUI_WHITE);
            GUI_DrawBitmap(&bmReturn, 40, 5);
        }
        break;
    default:
        BUTTON_Callback(pMsg);/* 按键默认的事件处理函数 */
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Emwin</category>
      </categories>
      <tags>
        <tag>Emwin</tag>
      </tags>
  </entry>
  <entry>
    <title>【Emwin】xbf字体制作及使用方法</title>
    <url>/posts/00000009/</url>
    <content><![CDATA[<h2 id="xbf字体的制作"><a href="#xbf字体的制作" class="headerlink" title="xbf字体的制作"></a>xbf字体的制作</h2><p>FontCvtST.exe软件是EWINM提供制作XBF字体和Slf字体的软件。</p>
<ol>
<li><p>打开FontCvtST.exe，选择字体生成类型为Standard, 编码为16 Bit Unicode</p>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageXBF%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%901.jpg" alt=""></p>
</li>
<li><p>选择生成字体，字形，大小</p>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageXBF%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%902.png" alt=""> </p>
</li>
<li><p>设置生成字体属性后的界面</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageXBF%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%903.png" alt=""></p>
<ol start="4">
<li><p>保存并生成XBF字体</p>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageXBF%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%904.png" alt=""></p>
</li>
</ol>
<h2 id="XBF字体使用"><a href="#XBF字体使用" class="headerlink" title="XBF字体使用"></a>XBF字体使用</h2><ul>
<li><p>使用XBF字体的注意事项</p>
<ol>
<li>使用XBF字体之前，需要调用GUI_UC_SetEncodeUTF8();</li>
<li>使用XBF字体之前，需要从外部存储中将XBF字体文件加载到内存中，并创建该字体</li>
<li>使用XBF字体时，需要打开XBF文件，如果之后不使用，则可以关闭这个文件；如果后面还需使用，则不能关闭该文件。</li>
<li>使用XBF字体时，需要把C文件的编码格式改为UTF-8,不然是无法使用。</li>
</ol>
</li>
<li><p>相关函数</p>
</li>
</ul>
<ul>
<li>XBF字体使用示例</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">void MainTask(void) {
  HANDLE hFile;

  GUI_Init();
  /*在使用XBF字体之前一定要调用该函数*/
  GUI_UC_SetEncodeUTF8();

  WM_SetCallback(WM_HBKWIN, _cbDesktop);

  char* acPath = "C:\\Users\\wl\\Desktop\\SeggerEval_WIN32_MSVC_MinGW_GUI_V610\\demo\\xbf\\song16.xbf";

  /*打开xbf字体文件*/

  hFile = CreateFile(acPath, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
  if (hFile != INVALID_HANDLE_VALUE)
  {
    /*vs 2019在编译UTF-8有时会出问题，
    一般只需在显示文字后面加.即可解决*/

    char* acShowString = "安富莱电子_ \n";

      /*创建XBF字体*/
    GUI_XBF_CreateFont(&Font,&XBF_Data,GUI_XBF_TYPE_PROP,_cbGetData, &hFile);
    GUI_DispStringHCenterAt("Press any key to continue...", 160, 120);
    GUI_SetFont(&Font);
    GUI_DispStringHCenterAt(acShowString, 160, 80);
      //CloseHandle(hFile);
  }
  else
  {
      GUI_DispStringAt("open fail", 100, 100);
  }

  while(1)
  {
    GUI_ExecDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), &_cbDialog, 0, 0, 0);
    GUI_Delay(1000);
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Emwin</category>
      </categories>
      <tags>
        <tag>Emwin</tag>
      </tags>
  </entry>
  <entry>
    <title>【Emwin】日历控件的使用</title>
    <url>/posts/0000000a/</url>
    <content><![CDATA[<h2 id="日历控件"><a href="#日历控件" class="headerlink" title="日历控件"></a>日历控件</h2><p>  日历对话框可用于选择或设置日期。</p>
<ul>
<li>日历控件可以支持的通知消息</li>
</ul>
<table>
<thead>
<tr>
<th align="center">消息</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CALENDAR_NOTIFICATION_MONTH_CLICKED</td>
<td align="center">月份/年份文本已被单击</td>
</tr>
<tr>
<td align="center">CALENDAR_NOTIFICATION_MONTH_RELEASED</td>
<td align="center">月份/年份文本已被释放</td>
</tr>
<tr>
<td align="center">WM_NOTIFICATION_CLICKED</td>
<td align="center">小部件被点击</td>
</tr>
<tr>
<td align="center">WM_NOTIFICATION_RELEASED</td>
<td align="center">小部件被释放</td>
</tr>
<tr>
<td align="center">WM_NOTIFICATION_SCROLL_CHANGED</td>
<td align="center">其中一个滚动按钮被按下</td>
</tr>
<tr>
<td align="center">WM_NOTIFICATION_SEL_CHANGED</td>
<td align="center">控件发生改变</td>
</tr>
</tbody></table>
<ul>
<li>日历控件支持的键盘反应</li>
</ul>
<table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">反应</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GUI_KEY_PGUP</td>
<td align="center">选择移回一个月前</td>
</tr>
<tr>
<td align="center">GUI_KEY_PGDOWN</td>
<td align="center">选择移回一个月后</td>
</tr>
<tr>
<td align="center">GUI_KEY_LEFT</td>
<td align="center">选择移动到左边</td>
</tr>
<tr>
<td align="center">GUI_KEY_RIGHT</td>
<td align="center">选择移动到右边</td>
</tr>
<tr>
<td align="center">GUI_KEY_UP</td>
<td align="center">选择向上移动一行</td>
</tr>
<tr>
<td align="center">GUI_KEY_DOWN</td>
<td align="center">选择向下移动一行</td>
</tr>
</tbody></table>
<h2 id="日历控件的相关函数"><a href="#日历控件的相关函数" class="headerlink" title="日历控件的相关函数"></a>日历控件的相关函数</h2><ul>
<li>创建一个日历控件</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">   原型：WM_HWIN CALENDAR_Create(WM_HWIN hParent,
                                 int xPos,
                                 int yPos,
                                 unsigned Year,
                                 unsigned Month,
                                 unsigned Day,
                                 unsigned FirstDayOfWeek,
                                 int Id,
                                 int Flags); 
   参数：hParent   接收NOTIFICATION 消息的父窗口的句柄
         xPos      客户端坐标中对话框的X位置(以像素为单位)
         yPos      客户端坐标中对话框的Y位置(以像素为单位)
         Year      当前的年数 (1582-9999)
         Month     当前的月份 (1-12)
         Day       当前的天数 (1-31)
         FirstDayOfWeek   日历控件从哪一个工作日开始(0-6 0=SA, 1=SO, … , 6=FR)
         Id        创建日历控件所使用的ID
         Flags     窗口小部件的附加标志(例如 WM_CF_SHOW  WM_CF_TRANS)

  返回值：成功对话框的句柄，否则为0

  注意：使用时一定要注意Year、Month、Day这个三个参数一定要在范围之内，要不然就会日历控件创建失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置用于新日历对话框的默认背景颜色</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型： void CALENDAR_SetDefaultBkColor(unsigned Index,GUI_COLOR Color);

  参数：Index 设置日历控件部分位置的背景颜色，具体设置那一部分需要参考下面的
              宏定义。
              CALENDAR_CI_WEEKEND ： 周末使用的背景色
              CALENDAR_CI_WEEKDAY ： 用于工作日的背景色
              CALENDAR_CI_SEL     ： 用于选择的背景颜色
              CALENDAR_CI_HEADER  ： 标题区域使用的背景颜色
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置用于标记日期的文本</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型： void CALENDAR_SetDefaultDays(const char ** apDays);
  参数： apDays : 指向包含字符串的7个字符串指针的数组的指针要使用。

  注意：数组的第一个字符串应该指向星期六的缩写，第二个字符串指向星期天。数组 需要至少有7个字符串。如果传递给函数的字符串太少，则emWin的行为将变得未定义

  例如：
  const char* apDays[] =
{
    "六.",
    "日.",
    "一.",
    "二.",
    "三.",
    "四.",
    "五.",
    "六.",
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置要用于当前月/年的文本</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型：void CALENDAR_SetDefaultMonths(const char ** apMonths);
  参数：apMonth : 指针指向一个包含12个字符串指针的数组要使用的字符串。 

  注意：数组的第一个字符串应该指向“January”的文本，第二个字符串应该指向文本
  例如“二月”等等。数组需要至少有12个字符串。如果太少的话传递给函数的字符串emWin的行为没有定义

  例如：
  const char* apMonths[] =
{
    "1月",
    "2月",
    "3月",
    "4月",
    "5月",
    "6月",
    "7月",
    "8月",
    "9月",
    "10月",
    "11月",
    "12月",
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置对话框使用的大小</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型：void CALENDAR_SetDefaultSize(unsigned Index, unsigned Size);
  参数：Index   要设置日历控件的位置，具体位置参考一下宏
                CALENDAR_SI_HEADER：设置标题区域的ysize
                CALENDAR_SI_CELL_X: 设置日历控件显示日期的单元格Xsize
                CALENDAR_SI_CELL_Y: 设置日历控件显示日期的单元格Ysize

  注意：完整对话框中x的大小可以计算如下:xSizeDialog = 7×CellSizeX
        完整对话框中y的大小可以计算如下:ySizeDialog = 7×CellSize+ HeaderSizeY          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>设置用于绘制日历控件的字体</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型：void CALENDAR_SetDefaultFont( unsigned Index,
                                      const GUI_FONT *  pFont);
  参数：Index : 用于那部分显示， 具体根据一下宏定以
                CALENDAR_FI_CONTENT ：用于标记和编号的字体
                CALENDAR_FI_HEADER  ：用于标题月/年使用的字体
        pFont : 要使用的字体
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="日历控件的使用"><a href="#日历控件的使用" class="headerlink" title="日历控件的使用"></a>日历控件的使用</h2><pre class="line-numbers language-C"><code class="language-C">  /*获取当前的年月日*/
  _Calendar_Date.Year  = (unsigned int)p->tm_year;
    _Calendar_Date.Month = (unsigned int)p->tm_mon;
    _Calendar_Date.Day   = (unsigned int)p->tm_mday;

    /*日历控件初始化 */
    CALENDAR_SetDefaultDays(apDays);
    CALENDAR_SetDefaultMonths(apMonths);

    CALENDAR_SetDefaultSize(CALENDAR_SI_HEADER, 35);
    CALENDAR_SetDefaultSize(CALENDAR_SI_CELL_X, 40);
    CALENDAR_SetDefaultSize(CALENDAR_SI_CELL_Y, 28);

    CALENDAR_SetDefaultColor(CALENDAR_CI_WEEKDAY, GUI_BLACK);
    CALENDAR_SetDefaultColor(CALENDAR_CI_WEEKEND, GUI_GRAY);
    CALENDAR_SetDefaultColor(CALENDAR_CI_LABEL, GUI_LIGHTBLUE);

    CALENDAR_SetDefaultFont(CALENDAR_FI_CONTENT, &Font);
    CALENDAR_SetDefaultFont(CALENDAR_FI_HEADER, &Font);

    hWinD = CALENDAR_Create(hWin, 450, 22, _Calendar_Date.Year + 1900, _Calendar_Date.Month, _Calendar_Date.Day, 2, GUI_ID_CALENDAR0, WM_CF_SHOW);
    if (hWinD == 0)
    {
        GUI_Log("error");
    }

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Emwin</category>
      </categories>
      <tags>
        <tag>Emwin</tag>
      </tags>
  </entry>
  <entry>
    <title>【keil】 iot_socket组件</title>
    <url>/posts/4/</url>
    <content><![CDATA[<h2 id="iot-socket-组件"><a href="#iot-socket-组件" class="headerlink" title="iot_socket 组件"></a>iot_socket 组件</h2><p> iot_socket 组件是keil对RL_TcpNet的bsd socket API 封装。</p>
<h2 id="iot-socket-API"><a href="#iot-socket-API" class="headerlink" title="iot_socket API"></a>iot_socket API</h2><ul>
<li><p>iotSocketCreate</p>
<pre class="line-numbers language-C"><code class="language-C">原型:int32_t iotSocketCreate (int32_t af, int32_t type, int32_t protocol) 
参数：
  af ：iot socket 地址类型
      IOT_SOCKET_AF_INET  -----   IPV4
      IOT_SOCKET_AF_INET6 -----   IPV6
 type: iot socket连接类型
      IOT_SOCKET_SOCK_STREAM
      IOT_SOCKET_SOCK_DGRAM
 protocol：
      IOT_SOCKET_IPPROTO_TCP ----  tcp协议控制
      IPPROTO_UDP            ----  udp协议控制
返回值：创建的socket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>iotSocketConnect</p>
<pre class="line-numbers language-C"><code class="language-C">原型：int32_t iotSocketConnect (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port)
参数：
  socket：连接的套接字
  ip    : ip地址
  ip_len：IP地址长度
          NET_ADDR_IP4_LEN
          NET_ADDR_IP6_LEN
  port  : 端口
返回值: 状态码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>iotSocketRecv</p>
<pre class="line-numbers language-C"><code class="language-C">原型：int32_t iotSocketRecv (int32_t socket, void *buf, uint32_t len) 
参数：
  socket：连接的套接字
  buf   : 要接收的数据缓冲区
  len   : 接收数据的长度
返回值: >0   接收字节数
     <0   错误码, 参考rc_bsd_to_iot错误码处理函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>iotSocketSend</p>
<pre class="line-numbers language-C"><code class="language-C">原型：int32_t iotSocketSend (int32_t socket, const void *buf, uint32_t len)
参数：
   socket：连接的套接字
   buf   : 发送数据的缓冲区
   len   : 发送数据的长度
返回值：>0  发送字节数
     <0  c错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2 id="使用iot-socket-API-编写客户端接收"><a href="#使用iot-socket-API-编写客户端接收" class="headerlink" title="使用iot socket API 编写客户端接收"></a>使用iot socket API 编写客户端接收</h2><pre class="line-numbers language-C"><code class="language-C"> void iot_thread(void)
{
    int32_t rc;  /*socket 套接字*/
    int32_t res; 
    uint8_t ip[4] = {192, 168, 1, 106};  
    uint16_t port = 2000;

    /*创建socket*/
    rc = iotSocketCreate(IOT_SOCKET_AF_INET, IOT_SOCKET_SOCK_STREAM, IOT_SOCKET_IPPROTO_TCP);

    /*连接指定的ip*/
    iotSocketConnect (rc, ip, NET_ADDR_IP4_LEN, port);

    while(1){

         /*等待接收*/
        res = iotSocketRecv (rc, _gBuf, 8);    
        if(res >= 0)
        {
          printf("iot_ok\r\n");
        }
            osDelay(500);    
   }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用iot-socket-API-编写客户端发送"><a href="#使用iot-socket-API-编写客户端发送" class="headerlink" title="使用iot socket API 编写客户端发送"></a>使用iot socket API 编写客户端发送</h2><pre class="line-numbers language-C"><code class="language-C"> uint8_t _gBuf[8] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};
void iot_thread(void)
{
    int32_t rc;
    int32_t res;
    uint8_t ip[4] = {192, 168, 1, 106};
    uint16_t port = 2000;
    rc = iotSocketCreate(IOT_SOCKET_AF_INET, IOT_SOCKET_SOCK_STREAM, IOT_SOCKET_IPPROTO_TCP);

    iotSocketConnect (rc, ip, NET_ADDR_IP4_LEN, port);

  while(1){

        /*发送数据*/
        res = iotSocketSend(rc, _gBuf, 8);
        if(res > 0 )
        {
           printf("send data %d byte\r\n", res);
        }
            osDelay(500);    
   }


}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>keil 组件</category>
      </categories>
      <tags>
        <tag>RTX5</tag>
      </tags>
  </entry>
  <entry>
    <title>【MQTT】MQTT调试助手mqttfx</title>
    <url>/posts/3/</url>
    <content><![CDATA[<h2 id="1-Mqttfx"><a href="#1-Mqttfx" class="headerlink" title="1. Mqttfx"></a>1. Mqttfx</h2><p>MQTT.fx是一款基于Eclipse Paho，使用Java语言编写的MQTT客户端工具。支持通过Topic订阅和发布消息，用来前期和物理云平台调试非常方便。</p>
<h2 id="2-Mqttfx使用"><a href="#2-Mqttfx使用" class="headerlink" title="2. Mqttfx使用"></a>2. Mqttfx使用</h2><ol>
<li>MQTT基本配置<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_fx.jpg" alt="MQTT基本配置"></li>
<li>MQTT Username及PassWord<br>这个是根据MQTT服务器是否需要UserName和PassWord来配置，有则根据协议规则来配置，没有可以不配。<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_fx_UserName_.png" alt="MQTT Username及PassWord"></li>
<li>MQTT 连接<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_fxConnect.png" alt="MQTT 连接"></li>
<li>MQTT 发布<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_Pulish.png" alt="MQTT 发布"></li>
<li>MQTT 订阅<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_Subscribe.png" alt="MQTT 订阅"></li>
<li>MQTT Debug<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageMQTT_Debug.png" alt="MQTT Debug"></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>【IAP】STM32 IAP在线升级</title>
    <url>/posts/7/</url>
    <content><![CDATA[<h2 id="STM32在线升级（IAP）"><a href="#STM32在线升级（IAP）" class="headerlink" title="STM32在线升级（IAP）"></a>STM32在线升级（IAP）</h2><h3 id="IAP与ISP"><a href="#IAP与ISP" class="headerlink" title="IAP与ISP"></a>IAP与ISP</h3><ul>
<li><p>ISP </p>
<blockquote>
<p>在系统可编程，指电路板上的空白器件可以编程写入最终用户代码， 而不需要从电路板上取下器件，已经编程的器件也可以用ISP方式擦除或再编程。这种方式需要将将BOOT管脚配置成上电从System Memory启动，System Memory中有一段BOOTLOADER来接收串口(对于STM32F407ZG来说，为USART1)来的数据，把它们烧写到FLASH中。<br>优势：不需要编程器就可以进行单片机的实验和开发，单片机芯片可以直接焊接到电路板上，调试结束即成成品，免去了调试时由于频繁地插入取出芯片对芯片和电路板带来的不便</p>
</blockquote>
</li>
<li><p>IAP</p>
<blockquote>
<p>IAP是In Application Programming的首字母缩写，IAP是用户自己的程序在运行过程中对User Flash的部分区域进行烧写，目的是为了在产品发布后可以方便地通过预留的通信口对产品中的固件程序进行更新升级。<br>优势：从结构上将Flash存储器映射为两个存储体，当运行一个存储体上的用户程序时，可对另一个存储体重新编程，之后将程序从一个存储体转向另一个。</p>
</blockquote>
</li>
</ul>
<h2 id="IAP的执行流程："><a href="#IAP的执行流程：" class="headerlink" title="IAP的执行流程："></a>IAP的执行流程：</h2><ol>
<li>bootload检测是否要升级程序并通过某种方式将固件bin文件传给要升级的设备（例如stm32）。</li>
<li>当升级设备开始接收到数据时，需要开始缓存数据并累计接收数据的大小</li>
<li>当数据接收完毕后即可开始将数据写入指定的内存地址并跳转执行</li>
</ol>
<h3 id="STM32内部FLASH分配"><a href="#STM32内部FLASH分配" class="headerlink" title="STM32内部FLASH分配"></a>STM32内部FLASH分配</h3><ol>
<li><p>正常使用烧写器烧写程序，整个flash中只有一个中断向量和用户代码<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_image20200213095409.jpg" alt="flash分配"></p>
<ol>
<li>IAP程序中分为Bootload,用户程序两部分<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageiapflah.jpg" alt="IAP flash分配"></li>
</ol>
</li>
</ol>
<h3 id="IAP程序实现"><a href="#IAP程序实现" class="headerlink" title="IAP程序实现"></a>IAP程序实现</h3><ol>
<li><p>设置用户代码的的跳转地址</p>
<pre class="line-numbers language-C"><code class="language-C">#define APP_START_ADDR       0x8010000      //应用程序起始地址(存放在FLASH)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>初始化时钟及串口外设</p>
<pre class="line-numbers language-C"><code class="language-C">
 bsp_Init();        /* 硬件初始化 */

 PrintfLogo();    /* 打印例程名称和版本等信息 */
 PrintfHelp();    /* 打印操作提示 */

 FLASH_If_Init();

 /* 如果用户区flash有写保护,在升级之前一定要解除写保护 */
 if (FLASH_If_GetWriteProtectionStatus() == 0)   
 {
     /* 解保护 */
     if(FLASH_If_DisableWriteProtection() == 1)
     {
         /* 解保护成功 */
         printf("\n\r解保护成功\n\r");
     }
     else
     {
         /* 解保护失败 */
         SerialPutString("解保护失败\r\n");
     }
 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>3.检测程序是否升级和升级程序及程序跳转<br>在</p>
<pre class="line-numbers language-C"><code class="language-C">
if(KEY1_StateRead()==KEY_DOWN)                   //如果KEY1被单击
    {

      printf("开始更新 APP\r\n");
      //更新FLASH代码      
          /* 下载新的用户代码到flash里面  */
            SerialDownload();
            printf ( "单击 KEY2，执行 APP\r\n" );
    }            
    else if(KEY2_StateRead()==KEY_DOWN)          //如果KEY2被单击
    {    
            printf ( "执行 APP\r\n" );

            HAL_Delay(1000);

            JumpAddress = *(__IO uint32_t*) (APPLICATION_ADDRESS + 4);
            /* 用户应用地址 */
            Jump_To_Application = (pFunction) JumpAddress;
            /* 初始化MSP */
            __set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);


            Jump_To_Application();
    }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="用户程序"><a href="#用户程序" class="headerlink" title="用户程序"></a>用户程序</h3><p>1.设置用户程序跳转地址，这个需要设置两个地方，一个是keil里flash地址设置和中断偏移量的设置</p>
<ul>
<li>flash地址设置<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageIAP%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE.png" alt="flash 地址设置"></li>
<li>中断偏移量设置<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageIAP%E7%94%A8%E6%88%B7%E4%B8%AD%E6%96%AD%E5%81%8F%E7%A7%BB%E8%AE%BE%E7%BD%AE.png" alt="中断偏移设置"></li>
</ul>
<p>2.设置程序编译文件格式为bin</p>
<blockquote>
<p>生成bin文件的命令：<br> fromelf.exe –bin -o ./Flash/Obj/output.bin  ./Flash/Obj/output.axf</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_image%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6bin.png" alt="生成bin文件"></p>
]]></content>
      <categories>
        <category>IAP</category>
      </categories>
      <tags>
        <tag>IAP</tag>
      </tags>
  </entry>
  <entry>
    <title>【RTX5】事件标志组</title>
    <url>/posts/2/</url>
    <content><![CDATA[<h1 id="事件标志组"><a href="#事件标志组" class="headerlink" title="事件标志组"></a>事件标志组</h1><blockquote>
<p>事件标志组是一种实现多任务同步机制。<br>优点：</p>
<ol>
<li>方便RTOS有效管理任务， 实现多任务之间的同步</li>
<li>有效解决中断服务程序和任务之间的同步问题</li>
</ol>
</blockquote>
<h2 id="事件标志API"><a href="#事件标志API" class="headerlink" title="事件标志API"></a>事件标志API</h2><h3 id="1-创建事件标志对象"><a href="#1-创建事件标志对象" class="headerlink" title="1. 创建事件标志对象"></a>1. 创建事件标志对象</h3><pre class="line-numbers language-C"><code class="language-C">原型 
osEventFlagsId_t osEventFlagsNew(const osEventFlagsAttr_t * attr)    
attr    : 事件标志属性   默认为NULL  
Returns : 返回事件ID , 出现错误则返回 NULL
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-设置定的事件标志"><a href="#2-设置定的事件标志" class="headerlink" title="2. 设置定的事件标志"></a>2. 设置定的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型： uint32_t osEventFlagsSet    (    osEventFlagsId_t     ef_id, uint32_t flags)    
ef_id   : 要设置事件的ID
flags   : 指定应设置的标志 ，该标志只能设置0bit - 30bit, 设置最高位则是设置错误代码
Returns : 返回设置后设置事件的标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-清除指定的事件标志"><a href="#3-清除指定的事件标志" class="headerlink" title="3.清除指定的事件标志"></a>3.清除指定的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型: uint32_t osEventFlagsClear    (    osEventFlagsId_t     ef_id, uint32_t     flags)
ef_id      : 要设置事件的ID
flags   : 指定应清除的标志
Returns ：返回清除前的事件标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-获取当前事件标志对象的事件标志"><a href="#4-获取当前事件标志对象的事件标志" class="headerlink" title="4. 获取当前事件标志对象的事件标志"></a>4. 获取当前事件标志对象的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型：uint32_t osEventFlagsGet    (osEventFlagsId_t     ef_id)
ef_id   ： 事件的ID
Returns ： 返回当前事件对象的事件标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="5-等待事件标志"><a href="#5-等待事件标志" class="headerlink" title="5. 等待事件标志"></a>5. 等待事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型：uint32_t osEventFlagsWait    (    osEventFlagsId_t     ef_id,
                                  uint32_t     flags,
                                  uint32_t     options,
                                  uint32_t     timeout 
                                 )    
ef_id   ： 所等待的事件对象
flags   ： 指定等待事件标志
options ： 等待条件
           osFlagsWaitAny        等待任何标志
           osFlagsWaitAll        等待所有标志
           osFlagsNoClear        不要清除已指定要等待的标志，一般用于手动清除

timeout ：系统等待事件标志的时间 ， 如果该值设为osWaitForever该函数将等待无限的
          时间，直到事件标志变为可用。
Returns ：如果等到事件标志则返回该事件标志或者返回错误码，错误码如下：
          osFlagsErrorUnknown(-1)   未指定的错误
          osFlagsErrorTimeout(-2)   在给定的时间内尚未设置等待的标志
          osFlagsErrorResource(-3)  未指定超时时，尚未设置等待的标志
          osFlagsErrorParameter(-4) 参数ef_id无法标识有效的事件标志对象或标志
                                    的最高位设置。
          osFlagsErrorISR      (-6) 该函数不能再中断里使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="6">
<li>删除事件标志对象</li>
</ol>
<pre class="line-numbers language-C"><code class="language-C">原型：osStatus_t osEventFlagsDelete( osEventFlagsId_t     ef_id    ) 
ef_id  : 事件对象
Returns: 状态代码，指示功能的执行状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="7-获取事件对象的名称"><a href="#7-获取事件对象的名称" class="headerlink" title="7. 获取事件对象的名称"></a>7. 获取事件对象的名称</h3><pre class="line-numbers language-C"><code class="language-C">ef_id  : 事件对象
Returns: 事件对象的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="事件标志组使用"><a href="#事件标志组使用" class="headerlink" title="事件标志组使用"></a>事件标志组使用</h2><ol>
<li>两个线程如何使用事件标志组通信示意图<br><img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_image%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%97%B4%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E9%80%9A%E4%BF%A1.PNG" alt=""></li>
</ol>
<h3 id="1-事件标志组使用示例"><a href="#1-事件标志组使用示例" class="headerlink" title="1. 事件标志组使用示例"></a>1. 事件标志组使用示例</h3><pre class="line-numbers language-C"><code class="language-C"> #include "cmsis_os2.h"                      

/*事件标志*/ 
#define FLAGS_MSK1 0x00000001U

/*事件对象*/ 
osEventFlagsId_t evt_id;                        

/*发送事件标志线程ID*/ 
osThreadId_t tid_Thread_EventSender;  
/*接收事件标志线程ID*/           
osThreadId_t tid_Thread_EventReceiver;          

void Thread_EventSender   (void *argument);  
void Thread_EventReceiver (void *argument);     

int Init_Events (void) {
  /*创建事件对象*/
  evt_id = osEventFlagsNew(NULL);
  if (evt_id == NULL) {
    /*线程对象创建失败处理*/
  }

 /*创建发送事件标志线程*/
  tid_Thread_EventSender = osThreadNew(Thread_EventSender, NULL, NULL);
  if (tid_Thread_EventSender == NULL) {
    return(-1);
  }
   /*创建接收事件标志线程*/
  tid_Thread_EventReceiver = osThreadNew(Thread_EventReceiver, NULL, NULL);
  if (tid_Thread_EventReceiver == NULL) {
    return(-1);
  }
  return(0);
}

void Thread_EventSender (void *argument) {

  while (1) {  
    /*设置事件标志*/  
    osEventFlagsSet(evt_id, FLAGS_MSK1);
    /*挂起任务*/
    osThreadYield();                           s
  }
}

void Thread_EventReceiver (void *argument) {
  uint32_t flags;

  while (1) {
    /*阻塞等待接收事件，直到等到该事件标志*/
    flags = osEventFlagsWait(evt_id, FLAGS_MSK1, osFlagsWaitAny, osWaitForever);

    /*根据等到的事件标志来执行相应的动作*/
    switch(flags)
    {
      case EVENT_1:

      break;
      case EVENT_2:

      break;
     default:
      break;
    }
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>嵌入式系统</category>
      </categories>
      <tags>
        <tag>RTX5</tag>
      </tags>
  </entry>
  <entry>
    <title>【uC/modbus】uC/modbus modbus_ascii移植及使用</title>
    <url>/posts/0000000c/</url>
    <content><![CDATA[<h2 id="ModBus-ASCII"><a href="#ModBus-ASCII" class="headerlink" title="ModBus ASCII"></a>ModBus ASCII</h2><ol>
<li><p>编码系统： 十六进制， ASCII字符0-9， A-F</p>
</li>
<li><p>报文中的每个 8 位字节以两个 ASCII 字符发送，例如一个字节0x58会被编码成两个字符：0x35(‘5’)和0x42(‘B’)</p>
</li>
<li><p>ModBus ASCII 报文帧格式  </p>
<table>
<thead>
<tr>
<th align="center">起始</th>
<th align="center">地址</th>
<th align="center">功能</th>
<th align="center">数据</th>
<th align="center">LRC</th>
<th align="center">结束</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1字符 ：</td>
<td align="center">2字符</td>
<td align="center">2字符</td>
<td align="center">0-2x252字符</td>
<td align="center">2字符</td>
<td align="center">2字符 CR LF</td>
</tr>
</tbody></table>
</li>
<li><p>LRC校验</p>
<blockquote>
<p>对报文中的所有的连续 8 位字节相加，忽略任何进位，然后求出其二进制补码,执行检<br>验针对不包括起始“冒号”和结尾 CRLF 对的整个 ASCII 报文域的内容</p>
</blockquote>
</li>
</ol>
<h2 id="uC-ModBus移植"><a href="#uC-ModBus移植" class="headerlink" title="uC/ModBus移植"></a>uC/ModBus移植</h2><h3 id="uC-ModBus源码文件目录结构"><a href="#uC-ModBus源码文件目录结构" class="headerlink" title="uC/ModBus源码文件目录结构"></a>uC/ModBus源码文件目录结构</h3><p>   <img src="https://cdn.jsdelivr.net/gh/wlyumu/blog_image/blog_imageuCMD%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt=""><br>  由于移植是在UCOS上添加的，所以只需要修改Port文件里的MB_bsp.c文件  </p>
<h3 id="MB-bsp文件，添加自己的串口驱动及中断处理："><a href="#MB-bsp文件，添加自己的串口驱动及中断处理：" class="headerlink" title="MB_bsp文件，添加自己的串口驱动及中断处理："></a>MB_bsp文件，添加自己的串口驱动及中断处理：</h3><ul>
<li>MB_CommPortCfg   ModBus设备配置  </li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">  原型：

  void MB_CommPortCfg (    MODBUS_CH *pch,           // 交流通道配置;
                                        CPU_INT08U port_nbr,             // 使用的串口物理号
                                        CPU_INT32U baud,            // 波特率
                                          CPU_INT08U bits,            // 位数
                                        CPU_INT08U parity,           // 校验方式
                                        CPU_INT08U stops )         // 停止位数
 {
   /*pch存储相关设备配置及接收数据*/
  if ( pch != (MODBUS_CH *)0 ) 
  {
     pch->PortNbr          = port_nbr;            // Store configuration in channel
     pch->BaudRate       = baud;
     pch->Parity             = parity;
     pch->Bits                = bits;
     pch->Stops            = stops;
                  /*串口设备初始化*/
                 //bsp_InitUart();

  }

}

用法： 在使用modbus前需要调用该函数对其串口初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>uart1_ReciveNew  中断接收数据  </li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型：
 void uart1_ReciveNew(uint8_t ch)
{
   MODBUS_CH *pch;
   pch = &MB_ChTbl[0];    

   //  pch->RxCtr++;
   MB_RxByte(pch, ch); 


}
用法：放在串口中断里接收每一个字节
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>MB_CommTx1   发送缓冲区里的一个字节  </li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型：
void MB_CommTx1 (    MODBUS_CH  *pch, 
                    CPU_INT08U c    ) 
{ 
    /*根据相应端口选择相应的发送函数*/
    switch (pch->PortNbr) 
    { 
        case 1 : comSendChar(COM1, c); break;
        case 2 : comSendChar(COM2, c); break;
        case 3 : comSendChar(COM3, c); break;
        default : break;
    } 
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>下面几个函数根据你的设备驱动实现方式选择移植  </li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">void MB_CommTxIntDis(MODBUS_CH *pch);   /*关闭发送中断*/
void MB_CommRxIntDis(MODBUS_CH *pch);   /*关闭接收中断*/
void MB_CommTxIntEn(MODBUS_CH *pch);    /*开启发送中断*/
void MB_CommRxIntEn(MODBUS_CH *pch);    /*开启发送中断*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>uC/modbus</category>
      </categories>
      <tags>
        <tag>ucos</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake用法</title>
    <url>/posts/1/</url>
    <content><![CDATA[<h2 id="Cmake基本用法"><a href="#Cmake基本用法" class="headerlink" title="Cmake基本用法"></a>Cmake基本用法</h2><ul>
<li>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)</li>
</ul>
<blockquote>
<p>指定Cmake最低版本需求 2.83</p>
</blockquote>
<ul>
<li>project(&lt;PROJECT-NAME&gt;)</li>
</ul>
<blockquote>
<p>指定项目名称  例如：PROJECT(hello)</p>
</blockquote>
<ul>
<li>AUX_SOURCE_DIRECTORY(&lt;dir&gt;   &lt;variable&gt;)</li>
</ul>
<blockquote>
<p>添加某路径下的所有源文件，并将该路径用变量来表示</p>
</blockquote>
<ul>
<li>ADD_EXECUTABLE(生成可执行文件的名字  变量)</li>
</ul>
<blockquote>
<p>ADD_EXECUTABLE(hello ${SRC_LIST})<br>将变量SRC_LIST表示路径下源文件编译，并生成可执行文件hello</p>
</blockquote>
<h2 id="同一目录，多文件"><a href="#同一目录，多文件" class="headerlink" title="同一目录，多文件"></a>同一目录，多文件</h2><blockquote>
<p>./Demo<br>|<br>+—-main.cc<br>|<br>+—-function.c<br>|<br>+—-function.h</p>
</blockquote>
<p>这种CmakeLists.txt写法如下：</p>
<blockquote>
<p>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)<br>project(Demo)<br>AUX_SOURCE_DIRECTORY(./Demo  SRC)<br>ADD_EXECUTABLE(function ${SRC})</p>
</blockquote>
<h2 id="多目录，多文件"><a href="#多目录，多文件" class="headerlink" title="多目录，多文件"></a>多目录，多文件</h2><blockquote>
<p>./Demo<br>|<br>+—main.cc<br>|<br>+—function/<br>|<br>+—function.cc<br>|<br>+—function.h</p>
</blockquote>
<p>主目录 CmakeLists.txt写法如下：</p>
<blockquote>
<p>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)<br>PROJECT(Demo)<br>AUX_SOURCE_DIRECTORY(./Demo SRC)<br>subdirectory(function)<br>ADD_EXECUTABLE(Demo ${SRC})</p>
</blockquote>
<p>子目录 CmakeLists.txt写法如下：</p>
<blockquote>
<p>AUX_SOURCE_DIRECTORY(. SUB_SRC)</p>
</blockquote>
<ul>
<li>find_package</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型 ：find_package(<package> [version] [EXACT] [QUIET] [MODULE]
            [REQUIRED] [[COMPONENTS] [components...]]
            [OPTIONAL_COMPONENTS components...]
            [NO_POLICY_SCOPE])
 <package>   :指定查找的软件包
 [QUIET]     :如果找不到软件包，该选项将禁用警告消息
 [MODULE]    :禁用下面记录的第二个签名
 [REQUIRED]  :其含义是指是否是工程必须的，表示如果没有找到的
              话，cmake的过程会终止，并发出警告信息
 [COMPONENTS]:在REQUIRED选项之后，或者如果没有指定REQUIRED选项
              但指定了COMPONENTS选项，在它们的后面可以列出一包
              相关(依赖)的部件清单。
示例 ： find_package(Protobuf REQUIRED)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>target_link_libraries</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型： target_link_libraries(<target> [item1] [item2] [...]
                         [[debug|optimized|general] <item>] ...)
用法： target_link_libraries(projectname  Libname);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>find_package 和 target_link_libraries示例</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">cmake_minimum_required(VERSION 2.8.3)
project(VMSClient)
set(CMAKE_AUTOMOC ON)
set(CMAKE_BUILD_TYPE RELEASE)
find_package(catkin REQUIRED COMPONENTS
        roscpp
        sensor_msgs
        std_msgs
        aisimba_msgs
        )

catkin_package()
find_package(Qt5Widgets REQUIRED)
find_package(Qt5Core REQUIRED)
find_package(Qt5Gui REQUIRED)
find_package(Qt5WebSockets REQUIRED)
find_package(Qt5Network REQUIRED)
find_package(Protobuf REQUIRED)

if (PROTOBUF_FOUND)
    message(STATUS "protobuf library found")
else ()
    message(FATAL_ERROR "protobuf library is needed but cant be found")
endif ()

include_directories(
        include
        ${catkin_INCLUDE_DIRS}
)

include_directories(${PROTOBUF_INCLUDE_DIRS})
include_directories(${PROJECT_SOURCE_DIR}/include)
include_directories(${PROJECT_SOURCE_DIR}/proto_src)

file(GLOB_RECURSE SRC src/*.c src/*.cpp proto_src/*.cc)
file(GLOB_RECURSE INC include/*.h include/*.hpp proto_src/*.h)

add_executable(${PROJECT_NAME}_node ${INC} ${SRC})
add_definitions(-std=c++11 -g -O3 -Wno-deprecated -Wno-dev)
add_dependencies(${PROJECT_NAME}_node ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})

target_link_libraries(${PROJECT_NAME}_node
        ${catkin_LIBRARIES}
        ${PROTOBUF_LIBRARIES}
        Qt5::Widgets
        Qt5::Core
        Qt5::Gui
        Qt5::WebSockets
        Qt5::Network
        glog
        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Cmake</category>
      </categories>
      <tags>
        <tag>自动化管理工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/1243066710/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>【Emwin】字体显示</title>
    <url>/posts/5/</url>
    <content><![CDATA[<h2 id="官方demo"><a href="#官方demo" class="headerlink" title="官方demo"></a>官方demo</h2><pre class="line-numbers language-C"><code class="language-C">#include "GUI.h"

#define RECOMMENDED_MEMPRY (1024L * 5)

void MainTask(void)
{
    int xPos;
    int yPos;
    int xSize;
    int i;
    i = 0;

    GUI_Init();

    if (GUI_ALLOC_GetNumFreeBytes() < RECOMMENDED_MEMPRY)
    {
        GUI_ErrorOut("not enough memory available");
        return;
    }

    xPos = LCD_GetXSize() / 2;
    yPos = LCD_GetYSize() / 2;

    GUI_SetTextMode(GUI_TM_REV);
    GUI_SetFont(GUI_FONT_20F_ASCII);
    GUI_DispStringHCenterAt("Hello world!", xPos, yPos);

    GUI_SetFont(GUI_FONT_D24X32);
    xSize = GUI_GetStringDistX("0000");
    xPos -= xSize / 2;
    yPos += 24 + 10;

    while (1)
    {
        GUI_DispDecAt(i ++, xPos, yPos, 4);
        if (i > 9999)
        {
            i = 0;
        }
    }

}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><ul>
<li>GUI_SetTextMode</li>
</ul>
<blockquote>
<p>原    型：int GUI_SetTextMode(int TextMode)<br>函数说明：设置文本模式<br>参    数：<br>      GUI_TEXTMODE_NORMAL      文本正常显示。这是默认设置;这个值等于0<br>       GUI_TEXTMODE_REV         文本反向显示。(实测背景色相反)<br>       GUI_TEXTMODE_TRANS       文本显示为透明<br>       GUI_TEXTMODE_XOR         文本反转背景</p>
</blockquote>
<ul>
<li>GUI_SetFont</li>
</ul>
<blockquote>
<p>原    型：const GUI_FONT * GUI_SetFont(const GUI_FONT * pNewFont)<br>函数说明：设置用于文本输出的字体<br>参    数：<br>         pNewFont:指向要选择和使用的字体的指针,例如GUI_FONT_20F_ASCII</p>
</blockquote>
<ul>
<li>GUI_DispStringHCenterAt</li>
</ul>
<blockquote>
<p>原    型：void GUI_DispStringHCenterAt(const char * s, int x, int y);<br>函数说明：显示作为参数传递的字符串在指定位置水平居中在当前窗口中使用当前字体<br>参    数：<br>        s:要显示的字符串<br>        x:显示位置横坐标<br>        y:显示位置纵坐标</p>
</blockquote>
<ul>
<li>GUI_GetStringDistX</li>
</ul>
<blockquote>
<p>原    型：int GUI_GetStringDistX(const char * s);<br>函数说明：返回用于以当前选定字体显示指定字符串的X-size<br>参    数：<br>        s:指定字符串</p>
</blockquote>
<ul>
<li>GUI_DispDecAt</li>
</ul>
<blockquote>
<p>原    型：void GUI_DispDecAt(I32 v, I16P x, I16P y, U8 Len);<br>函数说明：以十进制形式显示具有指定字符数的值，使用当前字体在当前窗口中的位置。<br>参    数：<br>        v  :显示的十进制的值<br>        x  :显示位置的横坐标<br>        y  :显示位置的纵坐标<br>        len:显示的最大位数</p>
</blockquote>
]]></content>
      <categories>
        <category>Emwin</category>
      </categories>
      <tags>
        <tag>Emwin</tag>
      </tags>
  </entry>
</search>
