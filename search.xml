<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【keil】 iot_socket组件</title>
    <url>/posts/4/</url>
    <content><![CDATA[<h2 id="iot-socket-组件"><a href="#iot-socket-组件" class="headerlink" title="iot_socket 组件"></a>iot_socket 组件</h2><p> iot_socket 组件是keil对RL_TcpNet的bsd socket API 封装。</p>
<h2 id="iot-socket-API"><a href="#iot-socket-API" class="headerlink" title="iot_socket API"></a>iot_socket API</h2><ul>
<li><p>iotSocketCreate</p>
<pre class="line-numbers language-C"><code class="language-C">原型:int32_t iotSocketCreate (int32_t af, int32_t type, int32_t protocol) 
参数：
  af ：iot socket 地址类型
      IOT_SOCKET_AF_INET  -----   IPV4
      IOT_SOCKET_AF_INET6 -----   IPV6
 type: iot socket连接类型
      IOT_SOCKET_SOCK_STREAM
      IOT_SOCKET_SOCK_DGRAM
 protocol：
      IOT_SOCKET_IPPROTO_TCP ----  tcp协议控制
      IPPROTO_UDP            ----  udp协议控制
返回值：创建的socket<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>iotSocketConnect</p>
<pre class="line-numbers language-C"><code class="language-C">原型：int32_t iotSocketConnect (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port)
参数：
  socket：连接的套接字
  ip    : ip地址
  ip_len：IP地址长度
          NET_ADDR_IP4_LEN
          NET_ADDR_IP6_LEN
  port  : 端口
返回值: 状态码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>iotSocketRecv</p>
<pre class="line-numbers language-C"><code class="language-C">原型：int32_t iotSocketRecv (int32_t socket, void *buf, uint32_t len) 
参数：
  socket：连接的套接字
  buf   : 要接收的数据缓冲区
  len   : 接收数据的长度
返回值: >0   接收字节数
     <0   错误码, 参考rc_bsd_to_iot错误码处理函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>iotSocketSend</p>
<pre class="line-numbers language-C"><code class="language-C">原型：int32_t iotSocketSend (int32_t socket, const void *buf, uint32_t len)
参数：
   socket：连接的套接字
   buf   : 发送数据的缓冲区
   len   : 发送数据的长度
返回值：>0  发送字节数
     <0  c错误码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h2 id="使用iot-socket-API-编写客户端接收"><a href="#使用iot-socket-API-编写客户端接收" class="headerlink" title="使用iot socket API 编写客户端接收"></a>使用iot socket API 编写客户端接收</h2><pre class="line-numbers language-C"><code class="language-C"> void iot_thread(void)
{
    int32_t rc;  /*socket 套接字*/
    int32_t res; 
    uint8_t ip[4] = {192, 168, 1, 106};  
    uint16_t port = 2000;

    /*创建socket*/
    rc = iotSocketCreate(IOT_SOCKET_AF_INET, IOT_SOCKET_SOCK_STREAM, IOT_SOCKET_IPPROTO_TCP);

    /*连接指定的ip*/
    iotSocketConnect (rc, ip, NET_ADDR_IP4_LEN, port);

    while(1){

         /*等待接收*/
        res = iotSocketRecv (rc, _gBuf, 8);    
        if(res >= 0)
        {
          printf("iot_ok\r\n");
        }
            osDelay(500);    
   }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用iot-socket-API-编写客户端发送"><a href="#使用iot-socket-API-编写客户端发送" class="headerlink" title="使用iot socket API 编写客户端发送"></a>使用iot socket API 编写客户端发送</h2><pre class="line-numbers language-C"><code class="language-C"> uint8_t _gBuf[8] = {0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88};
void iot_thread(void)
{
    int32_t rc;
    int32_t res;
    uint8_t ip[4] = {192, 168, 1, 106};
    uint16_t port = 2000;
    rc = iotSocketCreate(IOT_SOCKET_AF_INET, IOT_SOCKET_SOCK_STREAM, IOT_SOCKET_IPPROTO_TCP);

    iotSocketConnect (rc, ip, NET_ADDR_IP4_LEN, port);

  while(1){

        /*发送数据*/
        res = iotSocketSend(rc, _gBuf, 8);
        if(res > 0 )
        {
           printf("send data %d byte\r\n", res);
        }
            osDelay(500);    
   }


}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>keil 组件</category>
      </categories>
      <tags>
        <tag>RTX5</tag>
      </tags>
  </entry>
  <entry>
    <title>【MQTT】MQTT调试助手mqttfx</title>
    <url>/posts/3/</url>
    <content><![CDATA[<h2 id="1-Mqttfx"><a href="#1-Mqttfx" class="headerlink" title="1. Mqttfx"></a>1. Mqttfx</h2><p>MQTT.fx是一款基于Eclipse Paho，使用Java语言编写的MQTT客户端工具。支持通过Topic订阅和发布消息，用来前期和物理云平台调试非常方便。</p>
<h2 id="2-Mqttfx使用"><a href="#2-Mqttfx使用" class="headerlink" title="2. Mqttfx使用"></a>2. Mqttfx使用</h2><ol>
<li>MQTT基本配置<br><img src="https://static.cowtransfer.com/cloud-21d0557c-1718-403d-9fc5-422e4abc4590/pic/MQTT/MQTT.fx.jpg?onett=fdfa188413a4ebdb1ae5cee1ab2742cc&attname=MQTT.fx.jpg" alt="MQTT基本配置"></li>
<li>MQTT Username及PassWord<br>这个是根据MQTT服务器是否需要UserName和PassWord来配置，有则根据协议规则来配置，没有可以不配。<br><img src="https://static.cowtransfer.com/cloud-21d0557c-1718-403d-9fc5-422e4abc4590/pic/MQTT/MQTT.fx_UserName_.png?onett=fdfa188413a4ebdb1ae5cee1ab2742cc&attname=MQTT.fx_UserName_.png" alt="MQTT Username及PassWord"></li>
<li>MQTT 连接<br><img src="https://static.cowtransfer.com/cloud-21d0557c-1718-403d-9fc5-422e4abc4590/pic/MQTT/MQTT.fxConnect.png?onett=fdfa188413a4ebdb1ae5cee1ab2742cc&attname=MQTT.fxConnect.png" alt="MQTT 连接"></li>
<li>MQTT 发布<br><img src="https://static.cowtransfer.com/cloud-21d0557c-1718-403d-9fc5-422e4abc4590/pic/MQTT/MQTT_Pulish.png?onett=fdfa188413a4ebdb1ae5cee1ab2742cc&attname=MQTT_Pulish.png" alt="MQTT 发布"></li>
<li>MQTT 订阅<br><img src="https://static.cowtransfer.com/cloud-21d0557c-1718-403d-9fc5-422e4abc4590/pic/MQTT/MQTT_Subscribe.png?onett=fdfa188413a4ebdb1ae5cee1ab2742cc&attname=MQTT_Subscribe.png" alt="MQTT 订阅"></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>MQTT</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>【RTX5】事件标志组</title>
    <url>/posts/2/</url>
    <content><![CDATA[<h1 id="事件标志组"><a href="#事件标志组" class="headerlink" title="事件标志组"></a>事件标志组</h1><blockquote>
<p>事件标志组是一种实现多任务同步机制。<br>优点：</p>
<ol>
<li>方便RTOS有效管理任务， 实现多任务之间的同步</li>
<li>有效解决中断服务程序和任务之间的同步问题</li>
</ol>
</blockquote>
<h2 id="事件标志API"><a href="#事件标志API" class="headerlink" title="事件标志API"></a>事件标志API</h2><h3 id="1-创建事件标志对象"><a href="#1-创建事件标志对象" class="headerlink" title="1. 创建事件标志对象"></a>1. 创建事件标志对象</h3><pre class="line-numbers language-C"><code class="language-C">原型 
osEventFlagsId_t osEventFlagsNew(const osEventFlagsAttr_t * attr)    
attr    : 事件标志属性   默认为NULL  
Returns : 返回事件ID , 出现错误则返回 NULL
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="2-设置定的事件标志"><a href="#2-设置定的事件标志" class="headerlink" title="2. 设置定的事件标志"></a>2. 设置定的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型： uint32_t osEventFlagsSet    (    osEventFlagsId_t     ef_id, uint32_t flags)    
ef_id   : 要设置事件的ID
flags   : 指定应设置的标志 ，该标志只能设置0bit - 30bit, 设置最高位则是设置错误代码
Returns : 返回设置后设置事件的标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="3-清除指定的事件标志"><a href="#3-清除指定的事件标志" class="headerlink" title="3.清除指定的事件标志"></a>3.清除指定的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型: uint32_t osEventFlagsClear    (    osEventFlagsId_t     ef_id, uint32_t     flags)
ef_id      : 要设置事件的ID
flags   : 指定应清除的标志
Returns ：返回清除前的事件标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="4-获取当前事件标志对象的事件标志"><a href="#4-获取当前事件标志对象的事件标志" class="headerlink" title="4. 获取当前事件标志对象的事件标志"></a>4. 获取当前事件标志对象的事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型：uint32_t osEventFlagsGet    (osEventFlagsId_t     ef_id)
ef_id   ： 事件的ID
Returns ： 返回当前事件对象的事件标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="5-等待事件标志"><a href="#5-等待事件标志" class="headerlink" title="5. 等待事件标志"></a>5. 等待事件标志</h3><pre class="line-numbers language-C"><code class="language-C">原型：uint32_t osEventFlagsWait    (    osEventFlagsId_t     ef_id,
                                  uint32_t     flags,
                                  uint32_t     options,
                                  uint32_t     timeout 
                                 )    
ef_id   ： 所等待的事件对象
flags   ： 指定等待事件标志
options ： 等待条件
           osFlagsWaitAny        等待任何标志
           osFlagsWaitAll        等待所有标志
           osFlagsNoClear        不要清除已指定要等待的标志，一般用于手动清除

timeout ：系统等待事件标志的时间 ， 如果该值设为osWaitForever该函数将等待无限的
          时间，直到事件标志变为可用。
Returns ：如果等到事件标志则返回该事件标志或者返回错误码，错误码如下：
          osFlagsErrorUnknown(-1)   未指定的错误
          osFlagsErrorTimeout(-2)   在给定的时间内尚未设置等待的标志
          osFlagsErrorResource(-3)  未指定超时时，尚未设置等待的标志
          osFlagsErrorParameter(-4) 参数ef_id无法标识有效的事件标志对象或标志
                                    的最高位设置。
          osFlagsErrorISR      (-6) 该函数不能再中断里使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="6">
<li>删除事件标志对象</li>
</ol>
<pre class="line-numbers language-C"><code class="language-C">原型：osStatus_t osEventFlagsDelete( osEventFlagsId_t     ef_id    ) 
ef_id  : 事件对象
Returns: 状态代码，指示功能的执行状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="7-获取事件对象的名称"><a href="#7-获取事件对象的名称" class="headerlink" title="7. 获取事件对象的名称"></a>7. 获取事件对象的名称</h3><pre class="line-numbers language-C"><code class="language-C">ef_id  : 事件对象
Returns: 事件对象的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="事件标志组使用"><a href="#事件标志组使用" class="headerlink" title="事件标志组使用"></a>事件标志组使用</h2><ol>
<li>两个线程如何使用事件标志组通信示意图<br><img src="https://static.cowtransfer.com/cloud-21d0557c-1718-403d-9fc5-422e4abc4590/pic/RTX/%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%97%B4%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E9%80%9A%E4%BF%A1.PNG?onett=fdfa188413a4ebdb1ae5cee1ab2742cc&attname=%E4%B8%A4%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%97%B4%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%A0%87%E5%BF%97%E7%BB%84%E9%80%9A%E4%BF%A1.PNG" alt="logo"></li>
</ol>
<h3 id="1-事件标志组使用示例"><a href="#1-事件标志组使用示例" class="headerlink" title="1. 事件标志组使用示例"></a>1. 事件标志组使用示例</h3><pre class="line-numbers language-C"><code class="language-C"> #include "cmsis_os2.h"                      

/*事件标志*/ 
#define FLAGS_MSK1 0x00000001U

/*事件对象*/ 
osEventFlagsId_t evt_id;                        

/*发送事件标志线程ID*/ 
osThreadId_t tid_Thread_EventSender;  
/*接收事件标志线程ID*/           
osThreadId_t tid_Thread_EventReceiver;          

void Thread_EventSender   (void *argument);  
void Thread_EventReceiver (void *argument);     

int Init_Events (void) {
  /*创建事件对象*/
  evt_id = osEventFlagsNew(NULL);
  if (evt_id == NULL) {
    /*线程对象创建失败处理*/
  }

 /*创建发送事件标志线程*/
  tid_Thread_EventSender = osThreadNew(Thread_EventSender, NULL, NULL);
  if (tid_Thread_EventSender == NULL) {
    return(-1);
  }
   /*创建接收事件标志线程*/
  tid_Thread_EventReceiver = osThreadNew(Thread_EventReceiver, NULL, NULL);
  if (tid_Thread_EventReceiver == NULL) {
    return(-1);
  }
  return(0);
}

void Thread_EventSender (void *argument) {

  while (1) {  
    /*设置事件标志*/  
    osEventFlagsSet(evt_id, FLAGS_MSK1);
    /*挂起任务*/
    osThreadYield();                           s
  }
}

void Thread_EventReceiver (void *argument) {
  uint32_t flags;

  while (1) {
    /*阻塞等待接收事件，直到等到该事件标志*/
    flags = osEventFlagsWait(evt_id, FLAGS_MSK1, osFlagsWaitAny, osWaitForever);

    /*根据等到的事件标志来执行相应的动作*/
    switch(flags)
    {
      case EVENT_1:

      break;
      case EVENT_2:

      break;
     default:
      break;
    }
  }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>嵌入式系统</category>
      </categories>
      <tags>
        <tag>RTX5</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake用法</title>
    <url>/posts/1/</url>
    <content><![CDATA[<h2 id="Cmake基本用法"><a href="#Cmake基本用法" class="headerlink" title="Cmake基本用法"></a>Cmake基本用法</h2><ul>
<li>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)</li>
</ul>
<blockquote>
<p>指定Cmake最低版本需求 2.83</p>
</blockquote>
<ul>
<li>project(&lt;PROJECT-NAME&gt;)</li>
</ul>
<blockquote>
<p>指定项目名称  例如：PROJECT(hello)</p>
</blockquote>
<ul>
<li>AUX_SOURCE_DIRECTORY(&lt;dir&gt;   &lt;variable&gt;)</li>
</ul>
<blockquote>
<p>添加某路径下的所有源文件，并将该路径用变量来表示</p>
</blockquote>
<ul>
<li>ADD_EXECUTABLE(生成可执行文件的名字  变量)</li>
</ul>
<blockquote>
<p>ADD_EXECUTABLE(hello ${SRC_LIST})<br>将变量SRC_LIST表示路径下源文件编译，并生成可执行文件hello</p>
</blockquote>
<h2 id="同一目录，多文件"><a href="#同一目录，多文件" class="headerlink" title="同一目录，多文件"></a>同一目录，多文件</h2><blockquote>
<p>./Demo<br>|<br>+—-main.cc<br>|<br>+—-function.c<br>|<br>+—-function.h</p>
</blockquote>
<p>这种CmakeLists.txt写法如下：</p>
<blockquote>
<p>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)<br>project(Demo)<br>AUX_SOURCE_DIRECTORY(./Demo  SRC)<br>ADD_EXECUTABLE(function ${SRC})</p>
</blockquote>
<h2 id="多目录，多文件"><a href="#多目录，多文件" class="headerlink" title="多目录，多文件"></a>多目录，多文件</h2><blockquote>
<p>./Demo<br>|<br>+—main.cc<br>|<br>+—function/<br>|<br>+—function.cc<br>|<br>+—function.h</p>
</blockquote>
<p>主目录 CmakeLists.txt写法如下：</p>
<blockquote>
<p>CMAKE_MINIMUM_REQUIRED(VERSION 2.8.3)<br>PROJECT(Demo)<br>AUX_SOURCE_DIRECTORY(./Demo SRC)<br>subdirectory(function)<br>ADD_EXECUTABLE(Demo ${SRC})</p>
</blockquote>
<p>子目录 CmakeLists.txt写法如下：</p>
<blockquote>
<p>AUX_SOURCE_DIRECTORY(. SUB_SRC)</p>
</blockquote>
<ul>
<li>find_package</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型 ：find_package(<package> [version] [EXACT] [QUIET] [MODULE]
            [REQUIRED] [[COMPONENTS] [components...]]
            [OPTIONAL_COMPONENTS components...]
            [NO_POLICY_SCOPE])
 <package>   :指定查找的软件包
 [QUIET]     :如果找不到软件包，该选项将禁用警告消息
 [MODULE]    :禁用下面记录的第二个签名
 [REQUIRED]  :其含义是指是否是工程必须的，表示如果没有找到的
              话，cmake的过程会终止，并发出警告信息
 [COMPONENTS]:在REQUIRED选项之后，或者如果没有指定REQUIRED选项
              但指定了COMPONENTS选项，在它们的后面可以列出一包
              相关(依赖)的部件清单。
示例 ： find_package(Protobuf REQUIRED)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>target_link_libraries</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">原型： target_link_libraries(<target> [item1] [item2] [...]
                         [[debug|optimized|general] <item>] ...)
用法： target_link_libraries(projectname  Libname);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li>find_package 和 target_link_libraries示例</li>
</ul>
<pre class="line-numbers language-C"><code class="language-C">cmake_minimum_required(VERSION 2.8.3)
project(VMSClient)
set(CMAKE_AUTOMOC ON)
set(CMAKE_BUILD_TYPE RELEASE)
find_package(catkin REQUIRED COMPONENTS
        roscpp
        sensor_msgs
        std_msgs
        aisimba_msgs
        )

catkin_package()
find_package(Qt5Widgets REQUIRED)
find_package(Qt5Core REQUIRED)
find_package(Qt5Gui REQUIRED)
find_package(Qt5WebSockets REQUIRED)
find_package(Qt5Network REQUIRED)
find_package(Protobuf REQUIRED)

if (PROTOBUF_FOUND)
    message(STATUS "protobuf library found")
else ()
    message(FATAL_ERROR "protobuf library is needed but cant be found")
endif ()

include_directories(
        include
        ${catkin_INCLUDE_DIRS}
)

include_directories(${PROTOBUF_INCLUDE_DIRS})
include_directories(${PROJECT_SOURCE_DIR}/include)
include_directories(${PROJECT_SOURCE_DIR}/proto_src)

file(GLOB_RECURSE SRC src/*.c src/*.cpp proto_src/*.cc)
file(GLOB_RECURSE INC include/*.h include/*.hpp proto_src/*.h)

add_executable(${PROJECT_NAME}_node ${INC} ${SRC})
add_definitions(-std=c++11 -g -O3 -Wno-deprecated -Wno-dev)
add_dependencies(${PROJECT_NAME}_node ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS})

target_link_libraries(${PROJECT_NAME}_node
        ${catkin_LIBRARIES}
        ${PROTOBUF_LIBRARIES}
        Qt5::Widgets
        Qt5::Core
        Qt5::Gui
        Qt5::WebSockets
        Qt5::Network
        glog
        )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Cmake</category>
      </categories>
      <tags>
        <tag>自动化管理工程</tag>
      </tags>
  </entry>
  <entry>
    <title>【Emwin】显示字体</title>
    <url>/posts/5/</url>
    <content><![CDATA[<h2 id="官方demo"><a href="#官方demo" class="headerlink" title="官方demo"></a>官方demo</h2><pre class="line-numbers language-C"><code class="language-C">#include "GUI.h"

#define RECOMMENDED_MEMPRY (1024L * 5)

void MainTask(void)
{
    int xPos;
    int yPos;
    int xSize;
    int i;
    i = 0;

    GUI_Init();

    if (GUI_ALLOC_GetNumFreeBytes() < RECOMMENDED_MEMPRY)
    {
        GUI_ErrorOut("not enough memory available");
        return;
    }

    xPos = LCD_GetXSize() / 2;
    yPos = LCD_GetYSize() / 2;

    GUI_SetTextMode(GUI_TM_REV);
    GUI_SetFont(GUI_FONT_20F_ASCII);
    GUI_DispStringHCenterAt("Hello world!", xPos, yPos);

    GUI_SetFont(GUI_FONT_D24X32);
    xSize = GUI_GetStringDistX("0000");
    xPos -= xSize / 2;
    yPos += 24 + 10;

    while (1)
    {
        GUI_DispDecAt(i ++, xPos, yPos, 4);
        if (i > 9999)
        {
            i = 0;
        }
    }

}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><ul>
<li>GUI_SetTextMode</li>
</ul>
<blockquote>
<p>原    型：int GUI_SetTextMode(int TextMode)<br>函数说明：设置文本模式<br>参    数：<br>      GUI_TEXTMODE_NORMAL      文本正常显示。这是默认设置;这个值等于0<br>       GUI_TEXTMODE_REV         文本反向显示。(实测背景色相反)<br>       GUI_TEXTMODE_TRANS       文本显示为透明<br>       GUI_TEXTMODE_XOR         文本反转背景</p>
</blockquote>
<ul>
<li>GUI_SetFont</li>
</ul>
<blockquote>
<p>原    型：const GUI_FONT * GUI_SetFont(const GUI_FONT * pNewFont)<br>函数说明：设置用于文本输出的字体<br>参    数：<br>         pNewFont:指向要选择和使用的字体的指针,例如GUI_FONT_20F_ASCII</p>
</blockquote>
<ul>
<li>GUI_DispStringHCenterAt</li>
</ul>
<blockquote>
<p>原    型：void GUI_DispStringHCenterAt(const char * s, int x, int y);<br>函数说明：显示作为参数传递的字符串在指定位置水平居中在当前窗口中使用当前字体<br>参    数：<br>        s:要显示的字符串<br>        x:显示位置横坐标<br>        y:显示位置纵坐标</p>
</blockquote>
<ul>
<li>GUI_GetStringDistX</li>
</ul>
<blockquote>
<p>原    型：int GUI_GetStringDistX(const char * s);<br>函数说明：返回用于以当前选定字体显示指定字符串的X-size<br>参    数：<br>        s:指定字符串</p>
</blockquote>
<ul>
<li>GUI_DispDecAt</li>
</ul>
<blockquote>
<p>原    型：void GUI_DispDecAt(I32 v, I16P x, I16P y, U8 Len);<br>函数说明：以十进制形式显示具有指定字符数的值，使用当前字体在当前窗口中的位置。<br>参    数：<br>        v  :显示的十进制的值<br>        x  :显示位置的横坐标<br>        y  :显示位置的纵坐标<br>        len:显示的最大位数</p>
</blockquote>
]]></content>
      <categories>
        <category>Emwin</category>
      </categories>
      <tags>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/1243066710/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
